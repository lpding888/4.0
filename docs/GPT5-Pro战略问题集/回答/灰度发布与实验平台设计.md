下面给你一套**可实操的 Feature Flag / 灰度发布与实验平台设计**，覆盖：总体架构、数据模型、用户分流与规则引擎、动态配置、前后端接入、实验管理、监控报警，以及可直接落地的代码示例（后端 SDK、前端 React Hook）。
示例默认 **PostgreSQL + Redis**，后端示例用 **Node.js/TypeScript** 与 **Python**，前端示例用 **React**。

---

## 0. 结论与选型建议（先给答案）

**推荐落地路径（兼顾“现在能用 + 长期可扩展”）：**

* **核心思路：自研轻量控制平面 + 本地评估 SDK（低延迟，秒级回滚）**

  * 控制面（CP）：配置在 Postgres；发布时编译为“**已计算好的规则包**（compiled config）”放入 Redis；通过 Redis Pub/Sub 进行**秒级下发/失效**。
  * 数据面（DP）：各服务（后端/前端/边缘）**本地内存评估**，不会在请求链路调用外部服务（保证 p95 < 0.2ms）。
  * **一键回滚**：Admin 将 `is_on=false` 或将 rollout 权重设为 0，CP 写入新版本→发布→Redis 通知，SDK 即刻切换。

* **技术选型评估**（适配你的三类方案）：

  * **方案A 自研（DB+Redis）**：

    * 优点：零外部依赖、极低延迟、严格数据边界、成本可控、可与 AI 推理链路深度定制（比如按模型版本/机房/显卡类型分流）。
    * 风险：需要自己做 AB 统计与可视化（可先接 ClickHouse/Prometheus/Grafana/Amplitude 再补齐实验统计）。
  * **方案B 开源（Unleash / GrowthBook / PostHog）**：

    * **Unleash**：开源、语义清晰、策略/渐进放量/variants 支持好；适合“功能旗标 + 渐进放量 + 白名单”。([Unleash Documentation][1])
    * **GrowthBook**：开源，“旗标 + 实验”一体，实验统计体系成熟，适合把**实验**当“一等公民”。([GrowthBook Docs][2])
    * **PostHog**：分析+回放+旗标+实验一体，若你已用其产品分析，集成最省事。([PostHog][3])
  * **方案C 云服务（LaunchDarkly / Split.io 等）**：

    * **LaunchDarkly**：企业级、SLA、SDK 多、治理完善、内置 Kill Switch 模式一键熔断。预算充足、合规优先时首选。([LaunchDarkly][4])
    * **Split.io**：旗标 + 实验/指标闭环成熟，价格与供应商绑定是主要权衡点。（若考虑，结论与 LaunchDarkly 类似）

> **落地建议**
> 第一步：按本文自研 CP/DP（方案A）搭好“旗标与灰度”的**骨架**，优先保障“放量 & 回滚 & 白名单 & 同步”。
> 第二步：**实验统计**若短期不自建，可用 GrowthBook/自建 ClickHouse 做曝光/目标指标统计面板。
> 第三步：当用户/合规/多语言 SDK 需求陡增，再考虑引入云服务作**补充**或“多引擎适配层”。

---

## 1) 架构总览（控制面/数据面/事件面）

```
                ┌────────────── Admin Console ──────────────┐
                │  新增/修改 Flag、Segment、Experiment       │
                └───────────────┬───────────────────────────┘
                                │  (事务 + 审批 + 审计)
                                ▼
                        ┌─────────────────────┐
                        │   Postgres (CP)     │
                        │ flags/segments/     │
                        │ rules/experiments   │
                        └─────────┬───────────┘
                          (发布/编译)│
                    ┌──────────────▼───────────────┐
                    │  Compiler: 生成 compiled JSON│
                    │  - 展平优先级/区间/白名单     │
                    │  - 预计算百分比区间/变体      │
                    └──────────────┬───────────────┘
                                   │ set+publish
                 ┌─────────────────▼─────────────────┐
                 │ Redis (Cache + Pub/Sub + Version) │
                 └───▲───────────────────────────▲───┘
                     │                           │
          bootstrap  │                           │ subscribe/invalidate
     ┌───────────────┴───────────────┐  ┌────────┴─────────┐
     │   后端服务(Go/Node/Python)    │  │   前端(React/SSR) │
     │  SDK 内存评估(无网络调用)     │  │  SDK/Hook          │
     │  + OpenTelemetry埋点          │  │  + SSE/轮询更新    │
     └───────┬───────────────┬───────┘  └────────┬──────────┘
             │Exposure        │Metrics            │Exposure
             ▼                ▼                   ▼
        ┌───────────┐   ┌───────────┐      ┌───────────┐
        │ Kafka/KDS │→→ │ ClickHouse │  or │ PostHog   │
        └───────────┘   └───────────┘      └───────────┘
                (曝光/变体/错误率/延迟等指标）
```

---

## 2) 数据模型（PostgreSQL）

> 说明：为了**发布快**与**查询快**，用**规范化 + JSONB**混合。生产建议：所有修改走事务并写入审计日志。

```sql
-- 环境（dev/staging/prod）
CREATE TABLE environments (
  id SERIAL PRIMARY KEY,
  key TEXT UNIQUE NOT NULL  -- 'dev' | 'staging' | 'prod'
);

-- 旗标主体
CREATE TABLE flags (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  key TEXT NOT NULL,                          -- 全局唯一 key（如 smart_tryon_v2）
  name TEXT NOT NULL,
  description TEXT,
  type TEXT NOT NULL CHECK (type IN ('release','experiment','ops_kill_switch')),
  project TEXT NOT NULL,                      -- 多租户/多项目隔离（可扩展 workspace_id）
  created_by TEXT,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(project, key)
);

-- 环境配置（发布维度）
CREATE TABLE flag_env_settings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  flag_id UUID REFERENCES flags(id) ON DELETE CASCADE,
  env_id INT REFERENCES environments(id) ON DELETE CASCADE,
  version INT NOT NULL DEFAULT 1,                 -- 乐观锁 / 配置版本
  is_on BOOLEAN NOT NULL DEFAULT FALSE,           -- 主开关（Kill Switch 上层）
  fallthrough_variant TEXT,                       -- 默认为空：未命中规则返回 OFF；也可给默认变体
  payload JSONB,                                  -- 可选的携带数据（如参数）
  updated_at TIMESTAMPTZ DEFAULT now(),
  UNIQUE(flag_id, env_id)
);

-- 白名单（优先命中；可指定变体）
CREATE TABLE flag_whitelist (
  id BIGSERIAL PRIMARY KEY,
  flag_env_id UUID REFERENCES flag_env_settings(id) ON DELETE CASCADE,
  user_key TEXT NOT NULL,                         -- user_id/email/device_id 等
  forced_variant TEXT,                            -- 可空：仅打开，不指定变体
  UNIQUE(flag_env_id, user_key)
);

-- 用户分群（Segment）
CREATE TABLE segments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  key TEXT UNIQUE NOT NULL,
  name TEXT,
  description TEXT,
  conditions JSONB NOT NULL                      -- DSL: 见下文（地区/等级等）
);

-- 规则（优先级顺序执行）
CREATE TABLE flag_rules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  flag_env_id UUID REFERENCES flag_env_settings(id) ON DELETE CASCADE,
  priority INT NOT NULL,                          -- 数字越小优先级越高
  segment_id UUID REFERENCES segments(id),        -- 可空；为空表示“所有用户”
  stickiness_field TEXT NOT NULL DEFAULT 'user_id', -- 一致性哈希依据
  rollout INT NOT NULL CHECK (rollout BETWEEN 0 AND 10000), -- 0~10000 表示 0%~100%
  variants JSONB,                                 -- {"A":5000,"B":5000} 或空（纯开/关）
  constraints JSONB,                              -- 附加条件（环境/平台/版本等）
  UNIQUE(flag_env_id, priority)
);

-- 前置依赖（Prerequisites），如某旗标要求另一个旗标已打开/某变体
CREATE TABLE flag_prerequisites (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  flag_env_id UUID REFERENCES flag_env_settings(id) ON DELETE CASCADE,
  requires_flag_env_id UUID REFERENCES flag_env_settings(id) ON DELETE CASCADE,
  expected_variant TEXT                           -- 可空：仅要求开
);

-- 实验（绑定某个 flag_env 设置）
CREATE TABLE experiments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  key TEXT UNIQUE NOT NULL,
  flag_env_id UUID REFERENCES flag_env_settings(id) ON DELETE SET NULL,
  status TEXT NOT NULL CHECK (status IN ('draft','running','paused','stopped')),
  hypothesis TEXT,
  primary_metric TEXT,
  guardrail_metrics JSONB,                        -- 错误率、延迟等
  start_at TIMESTAMPTZ,
  end_at TIMESTAMPTZ,
  mde DOUBLE PRECISION,                           -- 最小可检测效应
  created_at TIMESTAMPTZ DEFAULT now()
);

-- 审计
CREATE TABLE audit_logs (
  id BIGSERIAL PRIMARY KEY,
  actor TEXT,
  entity_type TEXT,               -- 'flag' | 'segment' | 'experiment' | ...
  entity_id TEXT,
  action TEXT,                    -- 'create'|'update'|'publish'|'rollback'
  diff JSONB,
  created_at TIMESTAMPTZ DEFAULT now()
);
```

### 规则/分群 DSL（JSON）

* `segments.conditions` 示例：

```json
{
  "all": [
    {"field":"region","op":"in","values":["CN","US"]},
    {"field":"member_tier","op":">=","value":2}
  ]
}
```

* `flag_rules.constraints`（附加约束）示例：

```json
{"any":[
  {"field":"app","op":"=","value":"web"},
  {"field":"app_version","op":">=","value":"3.2.0"}
]}
```

* `flag_rules.variants`：使用万分比分桶，便于精细配比（合计 ≤ 10000）

```json
{"control":5000,"treatment":5000}
```

---

## 3) 用户分组与分流策略

**一致性哈希（Stickiness）**

* 以 `seed = flag_key + ":" + stickiness_id` 计算 `hash32(seed)`，再 `bucket = hash % 10000` → 0\~9999。
* `stickiness_id` 取优先级：`context[stickiness_field]`（如 user\_id）→ device\_id → stable cookie → 最后退化为 OFF（避免随机抖动）。
* 可按 `user_id`、`region`、`tenant_id` 等做一致性粘性；对“匿名用户”可退化到 `device_id`。
* 变体分配采用**第二次哈希**（如 `flag_key + ":var:" + stickiness_id"`），在每个命中规则内分配到其**权重区间**（variants）。
* 这样**跨前后端一致**、**跨会话稳定**，避免“闪烁”。

---

## 4) 规则引擎（命中逻辑）

**优先级（从高到低）：**

1. **系统 Kill Switch（平台级）**：运维熔断，全局 OFF（极端灾难）。
2. **Flag 环境级主开关 `is_on`**：为 `false` 时**直接 OFF**（白名单也不生效，确保一键止血）。
3. **白名单**：命中则 **强制 ON/强制变体**（除非上面 1/2 关闭）。
4. **Prerequisite（前置旗标）**：未满足直接 OFF。
5. **规则列表（按 priority 升序）**：

   * 先校验 `segment` + `constraints`；
   * 命中后按 `rollout` 百分比做分桶；
   * 命中分桶后，如 `variants` 存在，按权重再分配变体；
   * 命中即返回（短路）。
6. **Fallthrough**：返回 `fallthrough_variant` 或 OFF。

**伪代码（语言无关）**：

```text
function evaluate(flagKey, context):
  flag = CONFIG.flags[flagKey]
  if !flag: return OFF

  if !flag.is_on: return OFF

  if inWhitelist(flag, context.user_key):
      return forcedVariantOrON

  if !checkPrereqs(flag, context): return OFF

  for rule in flag.rules by priority:
      if matchSegment(rule.segment, context) and matchConstraints(rule.constraints, context):
          id = getStickinessId(rule.stickiness_field, context)
          if !id: continue
          b = bucket(hash(flagKey + ":" + id))          // 0..9999
          if b < rule.rollout:                          // 命中放量
              if rule.variants: return pickVariant(hash(flagKey + ":var:" + id), rule.variants)
              else: return ON
  return flag.fallthrough_variant or OFF
```

---

## 5) 动态配置加载（Redis 缓存 + Pub/Sub 通知）

**发布流程**

1. Admin 在 Console 修改旗标/规则 → 保存 DB。
2. **编译器**读取本次改动，生成 “**compiled config**”（每个 env 一份 JSON）：

   * 展平：有序规则、白名单集合、每条规则的 **预计算权重区间**；
   * 附上 `version`、`checksum/etag`；
3. 将 JSON 写 Redis：`SET ff:env:prod:v{N} <json>`，并 `SET ff:env:prod:current v{N}`；
4. `PUBLISH ff:env:prod {"type":"CONFIG_CHANGED","version":N}`。

**SDK 侧**

* 启动时 `GET ff:env:prod:current` → 取对应版本 JSON，放入内存。
* 订阅 `ff:env:<env>`，收到 `CONFIG_CHANGED` 立即拉取新版本替换（无锁双缓冲或 RCU）。
* 提供 `getSnapshot()`，服务内一次请求评估多旗标共用相同上下文与同一版本。

---

## 6) 前后端集成方式

* **后端**：在入口中间件构造 `context`（user\_id/tenant/region/member\_tier/app/app\_version），取 `snapshot`，在业务逻辑处 `isEnabled/getVariant`。
* **前端**：

  * SSR：在服务端拉取 config 并评估，首屏避免“闪烁”。
  * 客户端：通过 SSE（或定时轮询）获取新版本 ETag，更新内存。
  * 统一埋点 `exposure` 事件（旗标、变体、上下文摘要），发往 ClickHouse/PostHog/Kafka。

---

## 7) 实验管理（A/B、多变量）

* **实验定义**：在旗标上配置 `variants` 与 `rollout`（如 50/50）。
* **曝光事件**：在第一次使用受控代码路径时上报 `flag_key / variant / user_key / env / timestamp`。
* **指标采集**：

  * **主指标**（如“下单率/试衣成功率/延迟<500ms”），
  * **护栏指标**（错误率、p95、退款率）。
* **统计计算**：

  * 可选：先接 **GrowthBook** 做统计与可视化（Bayesian/频率学皆可），保持评估在本地、统计在外部。([GrowthBook Docs][2])
  * 或自建 ClickHouse + Notebook/Metabase 计算：**分桶一致性由 SDK 保证**。
* **实验生命周期**：`draft → running → (paused) → stopped`；停止后将旗标**固化为发布配置**并清理实验代码路径。

---

## 8) 监控与报警

**SDK 指标**（OpenTelemetry/Prometheus）：

* `flag_eval_latency_ms`（直方图）
* `flag_eval_errors_total`（计数）
* `flag_miss_total`（未找到旗标）
* `flag_exposure_total{flag,variant}`（计数）
* `flag_rollout_traffic{flag}`（当前命中比例）

**业务护栏**（与实验挂钩）：

* 每分钟：错误率/超时率/宏观转化差异的连涨连跌规则（CUSUM/Shewhart）报警。
* **自动回滚策略**（可选）：达到阈值→ Admin 自动写 `is_on=false` 并发布。

---

## 9) 代码示例

### 9.1 后端 SDK（TypeScript / Node.js）

> 说明：示例自包含算法（FNV-1a 32-bit），可在 Node/边缘环境运行。实际工程中将 Redis 客户端与 HTTP 引导封装为 `ConfigProvider`。

```ts
// types.ts
export type Context = {
  user_id?: string;
  device_id?: string;
  region?: string;
  member_tier?: number;
  tenant_id?: string;
  app?: 'web' | 'ios' | 'android' | 'svc';
  app_version?: string;
  [k: string]: any;
};

export type VariantWeights = Record<string, number>; // 万分比，如 {control:5000,treatment:5000}

export type Rule = {
  priority: number;
  segment?: any;         // DSL（编译后可为更高效结构）
  constraints?: any;
  stickiness_field: string; // 'user_id' | 'device_id' | ...
  rollout: number;       // 0..10000
  variants?: VariantWeights;
};

export type FlagConfig = {
  key: string;
  is_on: boolean;
  fallthrough_variant?: string | null;
  whitelist?: Record<string, string | null>; // user_key -> forcedVariant|null
  prerequisites?: { key: string; expected_variant?: string | null }[];
  rules: Rule[];
};

export type CompiledConfig = {
  version: number;
  flags: Record<string, FlagConfig>;
  checksum: string;
};
```

```ts
// hash.ts — FNV-1a 32bit
export function fnv1a32(str: string): number {
  let h = 0x811c9dc5;
  for (let i = 0; i < str.length; i++) {
    h ^= str.charCodeAt(i);
    h = (h + ((h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24))) >>> 0;
  }
  return h >>> 0;
}
export function bucket10000(seed: string): number {
  return fnv1a32(seed) % 10000; // 0..9999
}
```

```ts
// matchers.ts — 简化版 DSL 评估
function opEval(op: string, left: any, right: any): boolean {
  switch (op) {
    case '=': return left === right;
    case '!=': return left !== right;
    case 'in': return Array.isArray(right) && right.includes(left);
    case 'not_in': return Array.isArray(right) && !right.includes(left);
    case '>=': return Number(left) >= Number(right);
    case '<=': return Number(left) <= Number(right);
    case '>': return Number(left) > Number(right);
    case '<': return Number(left) < Number(right);
    default: return false;
  }
}
export function matchCond(tree: any, ctx: any): boolean {
  if (!tree) return true;
  if (tree.all) return tree.all.every((c: any) => matchCond(c, ctx));
  if (tree.any) return tree.any.some((c: any) => matchCond(c, ctx));
  if (tree.field) return opEval(tree.op, ctx[tree.field], tree.value ?? tree.values);
  return true;
}
```

```ts
// flag-client.ts
import { bucket10000 } from './hash';
import { matchCond } from './matchers';
import type { CompiledConfig, Context, FlagConfig } from './types';

export class FlagClient {
  private cfg: CompiledConfig | null = null;
  constructor(private loader: { load(): Promise<CompiledConfig>, onUpdate(cb:()=>void): void }) {}

  async init() {
    this.cfg = await this.loader.load();
    this.loader.onUpdate(async () => { this.cfg = await this.loader.load(); });
  }

  snapshot() { return this.cfg; }

  private getStickinessId(field: string, ctx: Context): string | null {
    return (ctx[field] ?? ctx.user_id ?? ctx.device_id ?? null) || null;
  }

  private evalPrereq(flagMap: Record<string, FlagConfig>, pre: {key:string;expected_variant?:string|null}, ctx: Context): boolean {
    const f = flagMap[pre.key];
    if (!f || !f.is_on) return false;
    // 简化：只要 f 命中（不校验变体）；可扩展：递归变体命中
    const res = this.getVariantInternal(f, flagMap, ctx);
    if (!res.enabled) return false;
    if (pre.expected_variant) return res.variant === pre.expected_variant;
    return true;
  }

  isEnabled(flagKey: string, ctx: Context): boolean {
    const r = this.getVariant(flagKey, ctx);
    return r.enabled;
  }

  getVariant(flagKey: string, ctx: Context): { enabled: boolean; variant?: string } {
    if (!this.cfg) return { enabled: false };
    const f = this.cfg.flags[flagKey];
    if (!f || !f.is_on) return { enabled: false };
    return this.getVariantInternal(f, this.cfg.flags, ctx);
  }

  private getVariantInternal(f: FlagConfig, map: Record<string, FlagConfig>, ctx: Context) {
    // 白名单
    const uk = ctx.user_id ?? ctx.device_id;
    if (uk && f.whitelist && uk in f.whitelist) {
      const forced = f.whitelist[uk];
      return { enabled: true, variant: forced ?? undefined };
    }
    // 前置
    if (f.prerequisites && !f.prerequisites.every(p => this.evalPrereq(map, p, ctx))) {
      return { enabled: false };
    }
    // 规则
    for (const rule of f.rules.sort((a,b)=>a.priority-b.priority)) {
      if (rule.segment && !matchCond(rule.segment, ctx)) continue;
      if (rule.constraints && !matchCond(rule.constraints, ctx)) continue;

      const sid = this.getStickinessId(rule.stickiness_field, ctx);
      if (!sid) continue;
      const b = bucket10000(`${f.key}:${sid}`);
      if (b < rule.rollout) {
        if (rule.variants) {
          const total = Object.values(rule.variants).reduce((s, n) => s + n, 0);
          const vb = bucket10000(`${f.key}:var:${sid}`);
          let acc = 0;
          for (const [name, weight] of Object.entries(rule.variants)) {
            acc += weight;
            if (vb < Math.min(acc, total)) return { enabled: true, variant: name };
          }
        }
        return { enabled: true };
      }
    }
    if (f.fallthrough_variant) return { enabled: true, variant: f.fallthrough_variant };
    return { enabled: false };
  }
}
```

**用法（Express 中间件示例）**：

```ts
// loader （示例：从 Redis/HTTP 拉取 + 订阅）
const loader = {
  async load() {
    // 生产：从 Redis/HTTP 拉取最新 compiled JSON；此处举例本地文件
    const txt = await import('./compiled.prod.json');
    return txt.default as CompiledConfig;
  },
  onUpdate(cb:()=>void) {
    // 生产：订阅 Redis Pub/Sub；收到消息后调用 cb()
  }
};

const client = new FlagClient(loader);
await client.init();

// Express
app.use(async (req, res, next) => {
  (req as any).flags = {
    isEnabled: (k: string) => client.isEnabled(k, {
      user_id: req.user?.id,
      region: req.headers['x-region'],
      member_tier: req.user?.tier
    }),
    getVariant: (k: string) => client.getVariant(k, {
      user_id: req.user?.id,
      region: req.headers['x-region'],
      member_tier: req.user?.tier
    })
  };
  next();
});

// 在路由中使用
app.get('/tryon', (req, res) => {
  const f = (req as any).flags.getVariant('smart_tryon_v2');
  if (f.enabled) {
    if (f.variant === 'new') return runNewPipeline(req, res);
    return runOldPipeline(req, res);
  } else {
    return runOldPipeline(req, res);
  }
});
```

**示例 compiled.prod.json（片段）**：

```json
{
  "version": 42,
  "checksum": "e3b0c44298...",
  "flags": {
    "smart_tryon_v2": {
      "key": "smart_tryon_v2",
      "is_on": true,
      "whitelist": { "vip_1001": "new", "vip_2333": null },
      "prerequisites": [],
      "rules": [
        {
          "priority": 10,
          "segment": {"all":[{"field":"region","op":"in","values":["CN","US"]},{"field":"member_tier","op":">=","value":2}]},
          "constraints": {"any":[{"field":"app","op":"=","value":"web"},{"field":"app","op":"=","value":"svc"}]},
          "stickiness_field": "user_id",
          "rollout": 1000, // 10% -> 1% 时可设为100
          "variants": {"old":5000,"new":5000}
        }
      ]
    }
  }
}
```

> **放量节奏**：1% → 10% → 50% → 100% 仅需修改该规则 `rollout` 字段（100 → 1000 → 5000 → 10000）并发布。

---

### 9.2 后端 SDK（Python 版，FastAPI 片段）

```python
# feature_flags.py
from typing import Dict, Any, Optional

def fnv1a32(s: str) -> int:
    h = 0x811c9dc5
    for ch in s:
        h ^= ord(ch)
        h = (h + ((h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24))) & 0xffffffff
    return h

def bucket10000(seed: str) -> int:
    return fnv1a32(seed) % 10000

def match(tree: Dict[str, Any], ctx: Dict[str, Any]) -> bool:
    if not tree: return True
    if 'all' in tree: return all(match(c, ctx) for c in tree['all'])
    if 'any' in tree: return any(match(c, ctx) for c in tree['any'])
    if 'field' in tree:
        op = tree['op']; left = ctx.get(tree['field']); right = tree.get('value', tree.get('values'))
        if op == '=': return left == right
        if op == '!=': return left != right
        if op == 'in': return isinstance(right, list) and left in right
        if op == 'not_in': return isinstance(right, list) and left not in right
        if op == '>=': return float(left) >= float(right)
        if op == '<=': return float(left) <= float(right)
        if op == '>': return float(left) > float(right)
        if op == '<': return float(left) < float(right)
    return True

class FlagClient:
    def __init__(self, loader):
        self.loader = loader
        self.cfg = None

    async def init(self):
        self.cfg = await self.loader.load()
        self.loader.on_update(lambda: None)  # 生产环境订阅 Redis 刷新

    def _stickiness_id(self, field: str, ctx: Dict[str, Any]) -> Optional[str]:
        return ctx.get(field) or ctx.get('user_id') or ctx.get('device_id')

    def get_variant(self, key: str, ctx: Dict[str, Any]):
        if not self.cfg: return {'enabled': False}
        f = self.cfg['flags'].get(key)
        if not f or not f.get('is_on'): return {'enabled': False}

        uk = ctx.get('user_id') or ctx.get('device_id')
        if uk and 'whitelist' in f and uk in f['whitelist']:
            forced = f['whitelist'][uk]
            return {'enabled': True, 'variant': forced} if forced else {'enabled': True}

        for rule in sorted(f.get('rules', []), key=lambda r: r['priority']):
            if rule.get('segment') and not match(rule['segment'], ctx): continue
            if rule.get('constraints') and not match(rule['constraints'], ctx): continue
            sid = self._stickiness_id(rule['stickiness_field'], ctx)
            if not sid: continue
            if bucket10000(f"{f['key']}:{sid}") < rule['rollout']:
                if 'variants' in rule and rule['variants']:
                    total = sum(rule['variants'].values())
                    vb = bucket10000(f"{f['key']}:var:{sid}")
                    acc = 0
                    for name, w in rule['variants'].items():
                        acc += w
                        if vb < min(acc, total):
                            return {'enabled': True, 'variant': name}
                return {'enabled': True}
        if f.get('fallthrough_variant'):
            return {'enabled': True, 'variant': f['fallthrough_variant']}
        return {'enabled': False}
```

---

### 9.3 前端集成（React：Provider + Hook）

> 特点：**SSR 预评估**避免闪烁；客户端通过 **SSE** 监听新版本；内置同款 FNV-1a 哈希保证与后端一致。

```tsx
// FeatureClient.ts
type Context = Record<string, any>;
type CompiledConfig = { version: number; flags: Record<string, any> };

function fnv1a32(str: string): number {
  let h = 0x811c9dc5;
  for (let i = 0; i < str.length; i++) { h ^= str.charCodeAt(i); h = (h + ((h<<1)+(h<<4)+(h<<7)+(h<<8)+(h<<24))) >>> 0; }
  return h >>> 0;
}
function bucket10000(seed: string){ return fnv1a32(seed) % 10000; }

function match(tree: any, ctx: any): boolean {
  if (!tree) return true;
  if (tree.all) return tree.all.every((c: any)=>match(c,ctx));
  if (tree.any) return tree.any.some((c: any)=>match(c,ctx));
  if (tree.field) {
    const left = ctx[tree.field]; const op = tree.op; const right = tree.value ?? tree.values;
    if (op==='=') return left === right;
    if (op==='!=') return left !== right;
    if (op==='in') return Array.isArray(right) && right.includes(left);
    if (op==='not_in') return Array.isArray(right) && !right.includes(left);
    if (op==='>=') return Number(left) >= Number(right);
    if (op==='<=') return Number(left) <= Number(right);
    if (op==='>') return Number(left) > Number(right);
    if (op==='<') return Number(left) < Number(right);
  }
  return true;
}

export class FeatureClient {
  private cfg: CompiledConfig | null = null;
  constructor(private url: string){}

  async init() {
    const r = await fetch(this.url, { credentials: 'include' });
    this.cfg = await r.json();
  }

  subscribeSSE(sseUrl: string, onUpdate?: ()=>void){
    const es = new EventSource(sseUrl, { withCredentials: true });
    es.onmessage = async (e) => {
      const msg = JSON.parse(e.data);
      if (msg.type === 'CONFIG_CHANGED') {
        const r = await fetch(this.url, { headers: {'If-None-Match': msg.etag ?? ''}, credentials:'include' });
        if (r.status === 200) { this.cfg = await r.json(); onUpdate?.(); }
      }
    };
    return () => es.close();
  }

  getVariant(key: string, ctx: Context): { enabled: boolean; variant?: string }{
    const cfg = this.cfg; if (!cfg) return { enabled:false };
    const f = cfg.flags[key]; if (!f || !f.is_on) return { enabled:false };

    const uk = ctx.user_id || ctx.device_id;
    if (uk && f.whitelist && (uk in f.whitelist)) {
      const forced = f.whitelist[uk];
      return forced ? { enabled:true, variant:forced } : { enabled:true };
    }

    for (const rule of [...(f.rules||[])].sort((a:any,b:any)=>a.priority-b.priority)) {
      if (rule.segment && !match(rule.segment, ctx)) continue;
      if (rule.constraints && !match(rule.constraints, ctx)) continue;
      const sid = ctx[rule.stickiness_field] || ctx.user_id || ctx.device_id;
      if (!sid) continue;
      const b = bucket10000(`${f.key}:${sid}`);
      if (b < rule.rollout) {
        if (rule.variants) {
          const total = Object.values(rule.variants).reduce((s:any,n:any)=>s+n,0);
          const vb = bucket10000(`${f.key}:var:${sid}`);
          let acc = 0;
          for (const [name, w] of Object.entries(rule.variants)) {
            acc += Number(w);
            if (vb < Math.min(acc, total)) return { enabled:true, variant:name };
          }
        }
        return { enabled:true };
      }
    }
    return f.fallthrough_variant ? { enabled:true, variant:f.fallthrough_variant } : { enabled:false };
  }
}
```

```tsx
// FeatureProvider.tsx
import React, { createContext, useContext, useEffect, useMemo, useState } from 'react';
import { FeatureClient } from './FeatureClient';

type Ctx = { user_id?: string; device_id?: string; region?: string; member_tier?: number; [k:string]:any; };
type API = { getVariant: (key: string) => {enabled:boolean; variant?: string} };

const FeatureContext = createContext<API>({ getVariant: () => ({enabled:false}) });

export function FeatureProvider({ children, bootstrapConfigUrl, sseUrl, context }: { children: React.ReactNode; bootstrapConfigUrl: string; sseUrl?: string; context: Ctx; }) {
  const [client] = useState(()=> new FeatureClient(bootstrapConfigUrl));
  const [, setTick] = useState(0);

  useEffect(()=>{ (async()=>{ await client.init(); setTick(x=>x+1); if (sseUrl) client.subscribeSSE(sseUrl, ()=>setTick(x=>x+1)); })(); }, [bootstrapConfigUrl, sseUrl]);

  const api = useMemo<API>(()=>({
    getVariant: (key: string) => client.getVariant(key, context)
  }), [client, context]);

  return <FeatureContext.Provider value={api}>{children}</FeatureContext.Provider>;
}

export function useFeature(key: string): { enabled: boolean; variant?: string } {
  const { getVariant } = useContext(FeatureContext);
  return getVariant(key);
}
```

**使用示例（前端组件）**：

```tsx
function TryOnButton() {
  const { enabled, variant } = useFeature('smart_tryon_v2');
  if (!enabled) return <LegacyTryOnButton/>;
  return variant === 'new' ? <NewTryOnButton/> : <LegacyTryOnButton/>;
}
```

---

## 10) 回滚机制（One-click Kill）

* **管理端**：`is_on=false` → 发布 → SDK 秒级生效。
* **策略级回滚**：将对应规则 `rollout` 调回上一步（如 5000 → 1000）。
* **自动化**（可选）：监控触发阈值即写入 `is_on=false`（带阻断名单），并在审计中标注“自动回滚”。

---

## 11) 上线与运营手册（建议流程）

1. **预发布**：内部白名单（员工/VIP 客户），灰度 `1%`。
2. **放量**：监控 30\~60 分钟（错误率/延迟/业务主指标），无异常升至 `10%` → `50%` → `100%`。
3. **实验**：如要评估效果，保持 50/50 变体 3\~7 天（视流量/MDE），在面板上查看可信区间或 p 值/后验胜率。
4. **固化**：胜出变体写入默认/老变体删除；保留旗标 1\~2 周作为 Kill Switch，再按模板归档/清理。

---

## 12) 安全与合规

* **最小化上下文**：SDK 评估不需要明文 PII；可对 `user_id` 做 **稳定哈希+盐** 后下发。
* **控制面 RBAC + 审批**：高风险旗标（ops\_kill\_switch）需双人审批。
* **审计**：所有配置变更写 `audit_logs`，记录 diff。
* **多租户隔离**：在 `segments.conditions`/规则约束中强制 `tenant_id=...`。

---

## 13) 方案对比（要点＋参考）

* **Unleash（开源，自托管）**：提供**激活策略**、**按上下文/百分比**灰度、**variants** 等，适合自研平台做“旗标内核”。([Unleash Documentation][1])
* **GrowthBook（开源，自托管/云）**：旗标 + **实验统计**一体，文档与社区完善；适合你们把实验做深。([GrowthBook Docs][2])
* **PostHog（开源/云）**：**分析 + 旗标 + 实验**同平台，若已用 PostHog 采集事件，集成成本最低。([PostHog][3])
* **LaunchDarkly（云）**：企业级旗标管理与**Kill Switch**最佳实践、API 完整、治理能力强，适合对 SLA 与合规有硬性要求的团队。([LaunchDarkly][4])
* **渐进放量与策略理念**（教程/文档参考）：Unleash 提供官方“渐进放量”教程，可作为自研策略的参考实现。([Unleash Documentation][5])

---

## 14) 你要的 1\~8 点逐条映射

1. **Feature Flag（功能开关）**：`flags + flag_env_settings.is_on` + `ops_kill_switch` 类型。
2. **灰度发布**：`flag_rules.rollout`（万分比），直接调 100→1000→5000→10000。
3. **用户分组**：`segments.conditions`（按 `user_id/region/member_tier/tenant_id`）。
4. **白名单**：`flag_whitelist`，优先级高于规则（但低于 `is_on=false`）。
5. **动态配置**：Redis 缓存 + Pub/Sub（版本化 JSON，SDK 秒级更新）。
6. **回滚机制**：`is_on=false` 一键总闸；或回撤 `rollout`；自动回滚可选。
7. **实验管理**：`variants` + 曝光埋点 + 指标平台（GrowthBook/ClickHouse）。
8. **完整代码**：已提供 Node/Python SDK、React Hook 与示例 compiled JSON。

---

### 15) 附：典型旗标配置示例（业务贴近）

**smart\_tryon\_v2**（AI 服装试穿新引擎）

* 类型：`experiment`
* 目标：提升“试穿成功率”和“出图时延 < 2s”。
* 放量：`1%`（1h）→ `10%`（2h）→ `50%`（1d）→ `100%`。
* 白名单：部分 VIP 用户与内部账号。
* 分群：`region in ["CN","US"] && member_tier >= 2`；app ∈ {web, svc}。
* 护栏：错误率不超过基线 + 50%，p95 延迟不劣化 > 15%。
* 自动化：触发护栏 → 写 `is_on=false` → 发布 → 通知 Slack/钉钉。

---

## 参考（少量关键出处）

* Unleash：激活策略/默认 100% 渐进/variants/粘性字段等。([Unleash Documentation][1])
* Unleash：渐进放量教程。([Unleash Documentation][5])
* GrowthBook：开源平台，旗标 + 实验。([GrowthBook Docs][2])
* GrowthBook：实验指南。([GrowthBook Docs][6])
* PostHog：旗标与实验文档/产品页。([PostHog][3])
* LaunchDarkly：旗标 API / Kill Switch / 命名规范与模板。([LaunchDarkly][4])

---

如果你希望，我可以把以上 SQL 与 SDK/Hook 整理成一个最小可运行的样例仓库结构（含编译器脚本与 Redis 模拟发布脚本），并给出一个“**从 1% 灰度到一键回滚**”的演练脚本，帮助你们把这套方案在一台机器上跑起来做端到端验收。

[1]: https://docs.getunleash.io/reference/feature-toggles?utm_source=chatgpt.com "Feature flags | Unleash Documentation"
[2]: https://docs.growthbook.io/?utm_source=chatgpt.com "GrowthBook Documentation | GrowthBook Docs"
[3]: https://posthog.com/docs/feature-flags?utm_source=chatgpt.com "Feature flags - Docs - PostHog"
[4]: https://launchdarkly.com/docs/api/feature-flags?utm_source=chatgpt.com "Feature flags | LaunchDarkly | Documentation"
[5]: https://docs.getunleash.io/feature-flag-tutorials/use-cases/gradual-rollout?utm_source=chatgpt.com "How to perform a gradual rollout | Unleash Documentation"
[6]: https://docs.growthbook.io/using?utm_source=chatgpt.com "Using GrowthBook | GrowthBook Docs"
