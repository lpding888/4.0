没问题！我把前端也一次性落地成**可执行的交付稿 v1**。实现严格对齐你在前端问题报告里的 P0/P1 清单，并与我刚交付的后端重构方案接口、事件命名完全打通（JWT 双 Token、WS 推送、支付回调等）。以下内容可直接拷到项目中，按章节替换/新增文件即可。 

---

# AI衣柜前端架构重构方案（交付稿 v1）

> 适配当前栈：Next.js 14 + React 18、Ant Design 5、Zustand、Axios、Tailwind。P0 优先包含：**密码登录/登录切换**、**双 Token 自动刷新**、**（暂保留）支付轮询→可切 WS**、**Sentry 监控**；P1 包含：**任务/支付 WS 推送**、**组件与测试** 等。

## 0. 快速清单（P0 / 立即可用）

* **登录页**支持「验证码登录 / 密码登录」切换，首次验证码登录后引导**设置密码**。
* **Axios 双 Token 刷新拦截器**：401 时自动用 Refresh Token 刷新、**单航班刷新**（避免风暴），刷新成功**重试原请求**，失败**统一登出**。
* **Zustand** 统一管理 `accessToken / refreshToken / user`，**多标签同步**。
* **Sentry** 客户端集成 + ErrorBoundary 自动上报 + Axios 错误上报入口。
* **与后端协议对齐**：JWT 由后端签发 Access(15m)+Refresh(7d)、刷新接口 `/auth/refresh`、登出 `/auth/logout`；保持与后端「统一认证中间件/WS 推送事件(task:updated / order:paid)」兼容。

> 注：支付功能真实可用需后端切换到微信/支付宝官方 SDK（我已在后端交付稿实现），前端无需改动流程，仅将轮询替换为 WS 即可（本稿提供替换代码）。

---

## 1. 目录与新文件

```
frontend/
  src/
    app/
      layout.tsx
      login/page.tsx
      membership/page.tsx          # 片段替换：可从轮询切 WS
      task/[taskId]/page.tsx       # 片段替换：可从轮询切 WS
      docs/api/page.tsx            # （可选）内置 SwaggerUI 页面
    components/
      ErrorBoundary.tsx            # 接入 Sentry
      TokenSyncProvider.tsx        # 多标签 Token 同步
    lib/
      api.ts                       # Axios 客户端 + 刷新拦截器（P0）
      socket.ts                    # Socket.IO 封装（P1）
    store/
      authStore.ts                 # 双 Token 管理（P0）
  sentry.client.config.ts          # Sentry 初始化（P1 但建议立即加）
  .env.example
```

---

## 2. 核心代码交付

### 2.1 Axios 客户端（双 Token 自动刷新 + 重试）

> 放置：`frontend/src/lib/api.ts`（**替换**）。支持：请求头自动带 AccessToken、401 自动刷新、**单航班刷新队列**、跨标签登出同步。 

```ts
// frontend/src/lib/api.ts
// Axios v1.6+ / TypeScript
import axios, { AxiosError, AxiosInstance, AxiosRequestConfig } from 'axios';

type RefreshResp = { accessToken: string; refreshToken?: string; user?: any };

let refreshingPromise: Promise<string | null> | null = null;
const refreshSubscribers: Array<(token: string | null) => void> = [];
const onAccessTokenFetched = (t: string | null) => {
  refreshSubscribers.splice(0).forEach(cb => cb(t));
};
const addRefreshSubscriber = (cb: (t: string | null) => void) => refreshSubscribers.push(cb);

const API_BASE = process.env.NEXT_PUBLIC_API_BASE!;

function safeCapture(err: any, extra?: Record<string, any>) {
  if (typeof window !== 'undefined') {
    import('@sentry/nextjs').then(S => S.captureException(err, { extra })).catch(() => {});
  }
}

export class APIClient {
  client: AxiosInstance;

  constructor(baseURL = API_BASE) {
    this.client = axios.create({ baseURL, timeout: 30000 });

    // 请求拦截：附带 AccessToken
    this.client.interceptors.request.use((config) => {
      if (typeof window !== 'undefined') {
        const token = localStorage.getItem('token');
        if (token) {
          config.headers = { ...(config.headers || {}), Authorization: `Bearer ${token}` };
        }
      }
      return config;
    });

    // 响应拦截：统一 data + 刷新逻辑
    this.client.interceptors.response.use(
      (resp) => (resp.data ?? resp),
      async (error: AxiosError) => {
        const status = error.response?.status;
        const original = (error.config || {}) as (AxiosRequestConfig & { _retry?: boolean });
        if (status === 401 && !original._retry) {
          original._retry = true;

          // 开始单航班刷新
          if (!refreshingPromise) {
            const rt = (typeof window !== 'undefined') ? localStorage.getItem('refresh_token') : null;
            if (!rt) {
              this.logoutSideEffects();
              return Promise.reject(error);
            }
            refreshingPromise = this.refresh(rt)
              .then((token) => token)
              .catch((e) => {
                safeCapture(e, { from: 'refreshToken' });
                this.logoutSideEffects();
                return null;
              })
              .finally(() => {
                const p = refreshingPromise; refreshingPromise = null;
                return p;
              });
          }

          // 队列等待刷新结果，再重试原请求
          return new Promise((resolve, reject) => {
            addRefreshSubscriber(async (newToken) => {
              if (!newToken) return reject(error);
              original.headers = { ...(original.headers || {}), Authorization: `Bearer ${newToken}` };
              try { resolve(await this.client.request(original)); }
              catch (e) { reject(e); }
            });
          });
        }

        // 非 401 的错误也走一遍 Sentry
        safeCapture(error, { url: (error.config as any)?.url, status });
        return Promise.reject(error);
      }
    );
  }

  private async refresh(refreshToken: string): Promise<string> {
    const url = `${API_BASE}/auth/refresh`;
    const resp = await axios.post<RefreshResp>(url, { refreshToken }, { timeout: 20000 });
    const { accessToken, refreshToken: newRT, user } = resp.data || (resp as any);
    if (typeof window !== 'undefined') {
      localStorage.setItem('token', accessToken);
      if (newRT) localStorage.setItem('refresh_token', newRT);
      if (user) localStorage.setItem('user', JSON.stringify(user));
      // 通知其他标签页
      window.dispatchEvent(new StorageEvent('storage', { key: 'token', newValue: accessToken }));
    }
    onAccessTokenFetched(accessToken);
    return accessToken;
  }

  private logoutSideEffects() {
    if (typeof window !== 'undefined') {
      localStorage.removeItem('token');
      localStorage.removeItem('refresh_token');
      localStorage.removeItem('user');
      // 通知其他标签页
      window.dispatchEvent(new StorageEvent('storage', { key: 'token', newValue: null as any }));
      window.location.href = '/login';
    }
  }

  // ---- API 封装 ----
  auth = {
    sendCode: (phone: string) => this.client.post('/auth/send-code', { phone }),
    loginWithCode: (phone: string, code: string) => this.client.post('/auth/login', { phone, code }),
    loginWithPassword: (phone: string, password: string) => this.client.post('/auth/login', { phone, password }),
    refreshToken: (refreshToken: string) => axios.post<RefreshResp>(`${API_BASE}/auth/refresh`, { refreshToken }).then(r => r.data),
    logout: (refreshToken: string) => axios.post(`${API_BASE}/auth/logout`, { refreshToken }).then(r => r.data),
    setPassword: (password: string) => this.client.post('/users/set-password', { password }),
    resetPassword: (phone: string, code: string, newPassword: string) =>
      this.client.post('/auth/reset-password', { phone, code, newPassword }),
  };

  tasks = {
    getDetail: (taskId: string) => this.client.get(`/tasks/${taskId}`),
  };

  membership = {
    purchase: (channel: 'wx'|'alipay') => this.client.post('/membership/purchase', { channel }),
    status: () => this.client.get('/membership/status'),
  };
}

export const api = new APIClient();
```

---

### 2.2 Zustand：统一管理双 Token + 多标签同步

> 放置：`frontend/src/store/authStore.ts`（**替换**）。在登录/刷新/登出时与 `localStorage` 保持一致；提供 `logout()` 便于组件调用。

```ts
// frontend/src/store/authStore.ts
'use client';
import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';

type User = { id: string; phone?: string; role?: string; nickname?: string; hasPassword?: boolean } | null;

interface AuthState {
  user: User;
  accessToken: string | null;
  refreshToken: string | null;
  setAuth: (u: User, at: string, rt: string) => void;
  updateUser: (patch: Partial<NonNullable<User>>) => void;
  logout: () => void;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      user: null,
      accessToken: null,
      refreshToken: null,
      setAuth: (user, accessToken, refreshToken) => {
        set({ user, accessToken, refreshToken });
        if (typeof window !== 'undefined') {
          localStorage.setItem('token', accessToken);
          localStorage.setItem('refresh_token', refreshToken);
          localStorage.setItem('user', JSON.stringify(user));
        }
      },
      updateUser: (patch) => set((s) => ({ user: s.user ? { ...s.user, ...patch } : s.user })),
      logout: () => {
        set({ user: null, accessToken: null, refreshToken: null });
        if (typeof window !== 'undefined') {
          localStorage.removeItem('token');
          localStorage.removeItem('refresh_token');
          localStorage.removeItem('user');
        }
      },
    }),
    {
      name: 'auth-storage',
      storage: createJSONStorage(() => localStorage),
      partialize: (s) => ({ user: s.user, accessToken: s.accessToken, refreshToken: s.refreshToken }),
    }
  )
);
```

**多标签同步组件**（建议在 `app/layout.tsx` 中挂载）：

```tsx
// frontend/src/components/TokenSyncProvider.tsx
'use client';
import { useEffect } from 'react';
import { useAuthStore } from '@/store/authStore';

export default function TokenSyncProvider() {
  const setAuth = useAuthStore(s => s.setAuth);
  const logout = useAuthStore(s => s.logout);

  useEffect(() => {
    const onStorage = (e: StorageEvent) => {
      if (e.key === 'token') {
        const at = localStorage.getItem('token');
        const rt = localStorage.getItem('refresh_token');
        const userStr = localStorage.getItem('user');
        const user = userStr ? JSON.parse(userStr) : null;
        if (at && rt) setAuth(user, at, rt);
        else logout();
      }
    };
    window.addEventListener('storage', onStorage);
    return () => window.removeEventListener('storage', onStorage);
  }, [setAuth, logout]);

  return null;
}
```

在 `app/layout.tsx` 里引入：

```tsx
// frontend/src/app/layout.tsx
import './globals.css';
import TokenSyncProvider from '@/components/TokenSyncProvider';
import '../sentry.client.config';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="zh-CN">
      <body>
        <TokenSyncProvider />
        {children}
      </body>
    </html>
  );
}
```

---

### 2.3 登录页（验证码/密码切换 + 首次设置密码）

> 放置：`frontend/src/app/login/page.tsx`（**替换**）。与后端统一登录接口契合：优先密码，备选验证码；登录成功保存**双 Token**。 

```tsx
// frontend/src/app/login/page.tsx
'use client';
import { useEffect, useState } from 'react';
import { Tabs, Form, Input, Button, message, Modal, Typography } from 'antd';
import { MobileOutlined, SafetyOutlined, LockOutlined } from '@ant-design/icons';
import { useRouter } from 'next/navigation';
import { api } from '@/lib/api';
import { useAuthStore } from '@/store/authStore';

const { Text } = Typography;

export default function LoginPage() {
  const router = useRouter();
  const setAuth = useAuthStore(s => s.setAuth);
  const [mode, setMode] = useState<'code' | 'password'>('code');
  const [sending, setSending] = useState(false);
  const [count, setCount] = useState(0);
  const [pwdModalOpen, setPwdModalOpen] = useState(false);

  // 倒计时
  useEffect(() => {
    if (count <= 0) return;
    const t = setTimeout(() => setCount(c => c - 1), 1000);
    return () => clearTimeout(t);
  }, [count]);

  const onSendCode = async (phone?: string) => {
    if (!phone) return message.warning('请输入手机号');
    setSending(true);
    try {
      await api.auth.sendCode(phone);
      setCount(60);
      message.success('验证码已发送');
    } finally { setSending(false); }
  };

  const onCodeLogin = async (v: { phone: string; code: string }) => {
    const r: any = await api.auth.loginWithCode(v.phone, v.code);
    handleLoginSuccess(r);
  };

  const onPasswordLogin = async (v: { phone: string; password: string }) => {
    const r: any = await api.auth.loginWithPassword(v.phone, v.password);
    handleLoginSuccess(r);
  };

  function handleLoginSuccess(r: any) {
    // 后端返回 { accessToken, refreshToken, user, needSetPassword? }
    if (!r) return;
    const { accessToken, refreshToken, user, needSetPassword } = r.data || r;
    setAuth(user, accessToken, refreshToken);
    if (needSetPassword || user?.hasPassword === false) {
      setPwdModalOpen(true);
    } else {
      message.success('登录成功');
      router.push('/workspace');
    }
  }

  async function onSetPassword(values: { password: string }) {
    await api.auth.setPassword(values.password);
    message.success('密码设置成功');
    setPwdModalOpen(false);
    router.push('/workspace');
  }

  return (
    <div className="max-w-md mx-auto mt-20 p-8 bg-white rounded shadow">
      <h2 className="text-2xl font-semibold mb-6">登录 AI衣柜</h2>
      <Tabs activeKey={mode} onChange={(k) => setMode(k as any)} items={[
        {
          key: 'code',
          label: '验证码登录',
          children: (
            <Form layout="vertical" onFinish={onCodeLogin}>
              <Form.Item name="phone" rules={[{ required: true, message: '请输入手机号' }]}>
                <Input prefix={<MobileOutlined />} placeholder="手机号" />
              </Form.Item>
              <Form.Item name="code" rules={[{ required: true, message: '请输入验证码' }]}>
                <Input prefix={<SafetyOutlined />} placeholder="6位验证码" />
              </Form.Item>
              <Form.Item noStyle shouldUpdate>
                {({ getFieldValue }) => (
                  <Button
                    type="dashed"
                    onClick={() => onSendCode(getFieldValue('phone'))}
                    disabled={count > 0 || sending}
                    className="mb-3"
                  >
                    {count > 0 ? `${count}s 后重发` : '发送验证码'}
                  </Button>
                )}
              </Form.Item>
              <Form.Item>
                <Button type="primary" htmlType="submit" block>登录</Button>
              </Form.Item>
              <div className="text-right">
                <a onClick={() => setMode('password')}>使用密码登录</a>
              </div>
            </Form>
          )
        },
        {
          key: 'password',
          label: '密码登录',
          children: (
            <Form layout="vertical" onFinish={onPasswordLogin}>
              <Form.Item name="phone" rules={[{ required: true, message: '请输入手机号' }]}>
                <Input prefix={<MobileOutlined />} placeholder="手机号" />
              </Form.Item>
              <Form.Item name="password" rules={[{ required: true, message: '请输入密码' }, { min: 6, message: '至少6位' }]}>
                <Input.Password prefix={<LockOutlined />} placeholder="密码" />
              </Form.Item>
              <Form.Item>
                <Button type="primary" htmlType="submit" block>登录</Button>
              </Form.Item>
              <div className="flex justify-between">
                <a onClick={() => setMode('code')}>改用验证码登录</a>
                <a href="/reset-password">忘记密码？</a>
              </div>
            </Form>
          )
        }
      ]} />

      <Modal title="设置密码" open={pwdModalOpen} onCancel={() => setPwdModalOpen(false)} footer={null}>
        <Text type="secondary">首次登录建议设置密码，之后可直接密码登录。</Text>
        <Form layout="vertical" onFinish={onSetPassword} className="mt-4">
          <Form.Item name="password" rules={[{ required: true }, { min: 6, message: '至少6位' }]}>
            <Input.Password prefix={<LockOutlined />} placeholder="设置登录密码" />
          </Form.Item>
          <Button type="primary" htmlType="submit" block>保存</Button>
        </Form>
      </Modal>
    </div>
  );
}
```

> 这部分完成了你报告中的**问题1（缺少密码登录）与登录切换/设置密码引导**，并与后端统一登录口、双 Token 机制对齐。 

---

### 2.4 WebSocket 封装（Socket.IO 客户端）

> 放置：`frontend/src/lib/socket.ts`（**新增**）。用于 P1 替换轮询：**任务状态** `task:updated`、**支付状态** `order:paid`，与我在后端交付稿中的房间模型 `user:${userId}` 对齐（连接后发送 `join` 事件）。

```ts
// frontend/src/lib/socket.ts
'use client';
import { io, Socket } from 'socket.io-client';

type TaskUpdate = { taskId: string; status: 'pending'|'running'|'failed'|'completed'; resultUrls?: string[]; error_msg?: string };
type OrderPaid = { orderId: string; channel: 'wx'|'alipay' };

class Realtime {
  private socket: Socket | null = null;
  private userId: string | null = null;

  connect(userId: string, token?: string) {
    if (this.socket?.connected) return;
    this.userId = userId;
    this.socket = io(process.env.NEXT_PUBLIC_WS_URL!, {
      path: '/ws',
      transports: ['websocket'],
      auth: token ? { token } : undefined,
      reconnection: true,
      reconnectionAttempts: 20,
      reconnectionDelay: 1000,
    });
    this.socket.on('connect', () => {
      // 与后端对齐：连接后发 join -> user room
      this.socket?.emit('join', userId);
    });
  }

  onTaskUpdated(handler: (p: TaskUpdate) => void) { this.socket?.on('task:updated', handler); }
  offTaskUpdated(handler: (p: TaskUpdate) => void) { this.socket?.off('task:updated', handler); }

  onOrderPaid(handler: (p: OrderPaid) => void) { this.socket?.on('order:paid', handler); }
  offOrderPaid(handler: (p: OrderPaid) => void) { this.socket?.off('order:paid', handler); }

  disconnect() {
    if (this.socket) { this.socket.disconnect(); this.socket = null; }
  }
}

export const realtime = new Realtime();
```

**在任务详情页替换轮询为 WS（片段）**

> 文件：`frontend/src/app/task/[taskId]/page.tsx` 原有指数退避轮询可保留为**兜底**，优先使用 WS。 

```tsx
// 片段：在组件内
useEffect(() => {
  if (!user?.id) return;
  realtime.connect(user.id, accessToken || undefined);

  const onUpdate = (payload: any) => {
    if (payload.taskId !== taskId) return;
    setTask((t: any) => ({ ...t, ...payload }));
    if (payload.status === 'completed') {
      message.success('任务完成');
    } else if (payload.status === 'failed') {
      message.error(payload.error_msg || '任务失败');
    }
  };
  realtime.onTaskUpdated(onUpdate);

  return () => { realtime.offTaskUpdated(onUpdate); };
}, [user?.id, accessToken, taskId]);
```

**在会员购买页替换支付轮询为 WS（片段）**

> 文件：`frontend/src/app/membership/page.tsx`，将 `setInterval` 轮询替换为：创建订单→展示二维码→**监听 `order:paid`**，收到后关闭弹窗刷新会员状态。

```tsx
useEffect(() => {
  if (!user?.id) return;
  realtime.connect(user.id, accessToken || undefined);

  const onPaid = (p: any) => {
    if (p.orderId !== orderIdRef.current) return;
    message.success('支付成功，已开通会员');
    setModalVisible(false);
    queryStatus(); // 刷新本地状态
  };

  realtime.onOrderPaid(onPaid);
  return () => realtime.offOrderPaid(onPaid);
}, [user?.id, accessToken]);
```

> 若后端暂未上 WS，保留现有轮询逻辑作为降级即可；等后端上线 WS 后删除轮询。（我在后端交付稿已提供 Socket.IO 服务端与事件发射。）

---

### 2.5 Sentry 集成（客户端）

> 放置：根目录 `frontend/sentry.client.config.ts`（**新增**），并在 `app/layout.tsx` 顶部 `import '../sentry.client.config'`。ErrorBoundary 自动上报；Axios 拦截器里也会调用。

```ts
// frontend/sentry.client.config.ts
import * as Sentry from '@sentry/nextjs';

if (process.env.NEXT_PUBLIC_SENTRY_DSN) {
  Sentry.init({
    dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
    environment: process.env.NODE_ENV,
    tracesSampleRate: 0.1,
    replaysSessionSampleRate: 0.01,
    ignoreErrors: ['ResizeObserver loop limit exceeded'],
  });
}
```

**ErrorBoundary 接入**（替换原文件以启用 Sentry 上报）

```tsx
// frontend/src/components/ErrorBoundary.tsx
'use client';
import React from 'react';
import * as Sentry from '@sentry/nextjs';

type Props = { children: React.ReactNode };
type State = { error: Error | null };

export default class ErrorBoundary extends React.Component<Props, State> {
  state: State = { error: null };
  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    this.setState({ error });
    Sentry.captureException(error, { extra: { componentStack: errorInfo.componentStack } });
  }
  render() {
    if (this.state.error) return <div className="p-8">页面出错了，请刷新重试。</div>;
    return this.props.children;
  }
}
```

> 这完成了你报告中的**问题5：缺少错误监控集成**，并将 Axios 错误也纳入捕获链。

---

### 2.6 （可选）前端内置 Swagger UI

> 如果后端已按交付稿开放 `/api-docs`，可在前端提供一个开发用页面快速查看。

```tsx
// frontend/src/app/docs/api/page.tsx
'use client';
import SwaggerUI from 'swagger-ui-react';
import 'swagger-ui-react/swagger-ui.css';

export default function APIDocsPage() {
  return <div className="h-screen"><SwaggerUI url={`${process.env.NEXT_PUBLIC_API_BASE}/api-docs-json`} /></div>;
}
```

---

## 3. 环境变量示例（.env.example）

```bash
# API & WS
NEXT_PUBLIC_API_BASE=http://localhost:3001/api
NEXT_PUBLIC_WS_URL=http://localhost:3001

# Sentry
NEXT_PUBLIC_SENTRY_DSN=

# Antd/Next 常规
NODE_ENV=development
```

---

## 4. 测试交付（示例用例可直接拓展）

### 4.1 单元测试（Axios 刷新队列）

> 关键验证点：401→仅一次 refresh 调用；等待队列请求被正确重试、刷新失败触发登出。

```ts
// frontend/tests/api.refresh.spec.ts
import axios from 'axios';
import MockAdapter from 'axios-mock-adapter';
import { APIClient } from '@/lib/api';

describe('API refresh interceptor', () => {
  const mock = new MockAdapter(axios);
  const api = new APIClient('http://test');

  beforeEach(() => {
    mock.reset();
    localStorage.setItem('refresh_token', 'RT');
    localStorage.setItem('token', 'AT_OLD');
  });

  it('should refresh once and replay queued requests', async () => {
    mock.onPost('http://test/auth/refresh').reply(200, { accessToken: 'AT_NEW', refreshToken: 'RT_NEW' });
    // 第一次请求 401
    mock.onGet('/foo').replyOnce(401);
    // 刷新成功后重试成功
    mock.onGet('/foo').reply(200, { ok: true });

    const p1 = api.client.get('/foo');
    const p2 = api.client.get('/foo');
    const [r1, r2] = await Promise.all([p1, p2]);
    expect(r1.ok && r2.ok).toBeTruthy();
  });
});
```

### 4.2 组件测试（登录切换）

```tsx
// frontend/tests/login.spec.tsx
import { render, screen, fireEvent } from '@testing-library/react';
import LoginPage from '@/app/login/page';

test('切换到密码登录并提交表单', async () => {
  render(<LoginPage />);
  fireEvent.click(screen.getByText('密码登录'));
  expect(await screen.findByPlaceholderText('密码')).toBeInTheDocument();
});
```

### 4.3 E2E（Playwright）脚本骨架

```ts
// frontend/tests/e2e/login.e2e.spec.ts
import { test, expect } from '@playwright/test';

test('验证码登录 → 设置密码引导', async ({ page }) => {
  await page.goto('/login');
  await page.getByText('验证码登录').click();
  await page.getByPlaceholder('手机号').fill('13800138000');
  // ……其余步骤视后端联调而定
  expect(true).toBeTruthy();
});
```

---

## 5. 实施路线图（不给时间，给工程量等级）

> **阶段 A / P0（立即上线）**
>
> 1. 登录页切换 + 设置密码弹窗（S）
> 2. Axios 双 Token 刷新 + 重试（M）
> 3. Zustand 双 Token 管理 + 多标签同步（S）
> 4. Sentry 客户端集成 + ErrorBoundary（S）
> 5. （保留支付轮询）等待后端真实支付 SDK 上线（无需前端改动） 

> **阶段 B / P1（增强）**
>
> 1. Socket.IO 封装接入（S），任务详情/支付页切换 WS（S~M）
> 2. 任务状态与支付事件 UI 联动（S）
> 3. 开发内置 Swagger 页（XS）
> 4. 覆盖更多测试（M）

**向后兼容要点**

* 若后端短期内仍返回 MOCK 支付二维码，前端维持轮询；切换 WS 时无需改业务逻辑。
* 双 Token 与后端刷新/吊销接口匹配；旧 Token 自然过期即可（Access 15m）。

---

## 6. 性能与稳定性

* **单航班刷新**避免并发 401 导致的刷新风暴。
* **WS 优先 + 轮询兜底**，在网络不佳时不影响核心流程。
* **Sentry** 捕获前端报错/接口异常，结合后端错误码提升排障效率。

---

## 7. 与后端的“事件/鉴权”对齐（确保即插即用）

* **JWT 双 Token**：登录返回 `{ accessToken, refreshToken, user }`；`/auth/refresh` 返回新 `accessToken`（可选 `refreshToken`）。前端已落地。
* **WS 事件**：后端向房间 `user:${userId}` 发 `task:updated` 与 `order:paid`；前端 `connect → emit('join', userId)` 即可收到。

---

### 结语

以上就是“前端 + 后端接口联动”的**一体化交付稿 v1**：

* 前端 P0 的登录切换、双 Token 刷新、Sentry 上报已经给出**可直接运行的代码**；
* P1 的 WS 改造也给出了**完整封装与页面改造片段**；
* 所有实现均与后端重构稿的接口/事件保持**一一对应**。
  如需要，我可以把这些文件按你当前 `frontend/src` 目录**批量拼成 PR 补丁**（按你仓库实际结构定位并最小化侵入差异）。如果你愿意，告诉我你当前的 `frontend/src` 目录快照，我直接给出**逐文件替换清单**与**diff**。
