下面是一套**可落地**的多租户（B2B）方案，覆盖架构、数据模型、方案对比、上下文传递、配置与计费、数据备份、性能优化、迁移计划，以及基于 **Express.js + Knex.js + MySQL 8 + Redis + Next.js 14** 的关键代码示例。为便于直接采用，我把建表 SQL、Knex 迁移、服务端中间件、RBAC 与查询封装都给出。

---

## 一、总体架构（推荐：A 方案为主，保留升级到 C 的能力）

**结论先行**

* **首选方案 A**：共享数据库 + 共享 schema（所有业务表加 `tenant_id`），适合多数中小与成长型企业客户，成本低、运维简单。
* **兼容“以大带小”的混合路线**：A 为默认；当出现**超大客户或合规要求**时，支持将该租户**提升为 C（独立数据库）**，通过 `tenants.connection_url` 进行“租户到库”的路由（数据迁移工具后文给出）。
* **暂不建议 B**（MySQL 的 schema 与 database 基本等价），成百上千 schema 的迁移与运维成本高且难以自动化。

### 1.1 运行时架构图（ASCII）

```
┌────────────────────────────────────────────────────────────────────────────┐
│                                Next.js 14                                  │
│ (app router / RSC / middleware)                                            │
│ - 解析子域/路径确定 tenant slug                                            │
│ - 主题(logo/品牌色/feature flag) SSR 注入                                  │
└───────────────▲────────────────────────────────────────────────────────────┘
                │ tenant slug / session
                │
┌───────────────┴────────────────────────────────────────────────────────────┐
│                         API (Express.js)                                   │
│  [Auth & Tenant Middleware]                                                 │
│   - 验证 JWT/Session/SAML，解析 tid/uid/role                                │
│   - 租户存在性 & 成员关系校验（Redis 热缓存）                               │
│   - AsyncLocalStorage 保存 request-scope {tenantId, userId, role}          │
│  [RBAC] 面向能力的权限检查                                                  │
│  [Repo/Service] 使用 "Tenant-Scoped Knex" 强制 WHERE tenant_id              │
└───────────────▲────────────────────────────────────────────────────────────┘
                │ SQL (scoped)         │ cache (scoped)        │ jobs (scoped)
                │                      │                       │
        ┌───────┴───────┐      ┌───────┴───────┐         ┌─────┴───────────┐
        │   MySQL 8.0    │      │     Redis     │         │  Worker/Queue   │
        │  (方案A主库)   │      │ tenant:* keys │         │  (传递tenantId) │
        └───────────────┘      └───────────────┘         └─────────────────┘

      * 大租户可切换至独库 (方案C)：tenants.connection_url 指向其专属RDS/实例
```

---

## 二、数据模型设计（核心三表 + RBAC + 计费 + 使用量）

> 你已有 `users`（全局用户表）。多租户需要引入 `tenants / tenant_members / tenant_configs` 以及计费与用量相关表。以下为 **MySQL 8** 兼容的 DDL（可直接放入 Knex 迁移）。

### 2.1 核心租户与成员

```sql
-- 租户表：企业维度
CREATE TABLE tenants (
  id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  slug VARCHAR(63) NOT NULL,                          -- 用于子域或路径 /t/:slug
  name VARCHAR(255) NOT NULL,
  status ENUM('active','suspended','deleted') NOT NULL DEFAULT 'active',
  logo_url VARCHAR(512),
  brand_primary CHAR(7),                              -- #RRGGBB
  brand_secondary CHAR(7),
  config_version INT NOT NULL DEFAULT 1,              -- 配置变更时++，用于缓存失效
  billing_mode ENUM('trial','paid','po','internal') DEFAULT 'trial',
  connection_url VARCHAR(1024) NULL,                  -- 若走方案C，指向专属DB
  created_at DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  updated_at DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3)
               ON UPDATE CURRENT_TIMESTAMP(3),
  UNIQUE KEY uq_tenants_slug (slug),
  KEY idx_tenants_status (status)
) ENGINE=InnoDB;

-- 租户成员：用户与租户的多对多关系 + 角色
CREATE TABLE tenant_members (
  id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  tenant_id BIGINT UNSIGNED NOT NULL,
  user_id   BIGINT UNSIGNED NOT NULL,
  role ENUM('owner','admin','member','viewer') NOT NULL DEFAULT 'member',
  status ENUM('active','invited','disabled') NOT NULL DEFAULT 'active',
  invited_by BIGINT UNSIGNED NULL,
  created_at DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  updated_at DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3)
               ON UPDATE CURRENT_TIMESTAMP(3),
  UNIQUE KEY uq_member (tenant_id, user_id),
  KEY idx_member_role (tenant_id, role),
  CONSTRAINT fk_tm_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE,
  CONSTRAINT fk_tm_user   FOREIGN KEY (user_id)   REFERENCES users(id)   ON DELETE CASCADE
) ENGINE=InnoDB;

-- 租户配置：可扩展 key-value（JSON），也可把部分放到 tenants 上
CREATE TABLE tenant_configs (
  id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  tenant_id BIGINT UNSIGNED NOT NULL,
  `key` VARCHAR(64) NOT NULL,                         -- e.g. 'theme', 'feature.remove_bg'
  `value` JSON NOT NULL,                              -- e.g. {"primary":"#...", "logo": "..."}
  is_secret BOOLEAN NOT NULL DEFAULT 0,               -- 若为密钥类，建议KMS加密后入库
  version INT NOT NULL DEFAULT 1,
  updated_by BIGINT UNSIGNED NULL,
  created_at DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  updated_at DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3)
               ON UPDATE CURRENT_TIMESTAMP(3),
  UNIQUE KEY uq_tenant_key (tenant_id, `key`),
  CONSTRAINT fk_tc_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE
) ENGINE=InnoDB;

-- 可选：邀请记录（邮件邀请、过期/撤回）
CREATE TABLE tenant_invitations (
  id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  tenant_id BIGINT UNSIGNED NOT NULL,
  email VARCHAR(320) NOT NULL,
  role ENUM('admin','member','viewer') NOT NULL,
  token CHAR(36) NOT NULL,                            -- uuid
  status ENUM('pending','accepted','expired','revoked') DEFAULT 'pending',
  expires_at DATETIME(3) NOT NULL,
  invited_by BIGINT UNSIGNED,
  created_at DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  updated_at DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3)
               ON UPDATE CURRENT_TIMESTAMP(3),
  UNIQUE KEY uq_tenant_invite (tenant_id, email),
  UNIQUE KEY uq_token (token),
  CONSTRAINT fk_ti_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE
) ENGINE=InnoDB;
```

### 2.2 企业级计费（套餐 + 订阅 + 用量）

```sql
-- 计费套餐（功能开关与额度写入 JSON）
CREATE TABLE plans (
  id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  code VARCHAR(64) NOT NULL UNIQUE,                   -- e.g. 'pro', 'enterprise'
  name VARCHAR(255) NOT NULL,
  periodicity ENUM('monthly','yearly') DEFAULT 'monthly',
  price_cents INT UNSIGNED NOT NULL,
  currency CHAR(3) NOT NULL DEFAULT 'USD',
  limits JSON NOT NULL,                               -- {"images_per_month": 10000, "storage_gb": 50}
  features JSON NOT NULL,                             -- {"remove_bg": true, "quality_4k": false}
  created_at DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  updated_at DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3)
               ON UPDATE CURRENT_TIMESTAMP(3)
) ENGINE=InnoDB;

-- 订阅（每租户一条“当前活跃订阅”，历史保留）
CREATE TABLE subscriptions (
  id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  tenant_id BIGINT UNSIGNED NOT NULL,
  plan_id BIGINT UNSIGNED NOT NULL,
  status ENUM('trialing','active','past_due','canceled') NOT NULL,
  current_period_start DATETIME(3) NOT NULL,
  current_period_end   DATETIME(3) NOT NULL,
  cancel_at_period_end BOOLEAN NOT NULL DEFAULT 0,
  external_customer_id VARCHAR(128),                  -- 第三方（如 Stripe）客户ID
  external_subscription_id VARCHAR(128),
  created_at DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  updated_at DATETIME(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3)
               ON UPDATE CURRENT_TIMESTAMP(3),
  KEY idx_sub_tenant_period (tenant_id, current_period_end),
  KEY idx_ext (external_subscription_id),
  CONSTRAINT fk_sub_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE,
  CONSTRAINT fk_sub_plan   FOREIGN KEY (plan_id)   REFERENCES plans(id)
) ENGINE=InnoDB;

-- 用量计数（按周期聚合，所有成员共享）
CREATE TABLE tenant_usage_counters (
  id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  tenant_id BIGINT UNSIGNED NOT NULL,
  meter_code VARCHAR(64) NOT NULL,                    -- 'image_process', 'storage_bytes'
  period_start DATETIME(3) NOT NULL,
  period_end   DATETIME(3) NOT NULL,
  used BIGINT UNSIGNED NOT NULL DEFAULT 0,
  soft_limit BIGINT UNSIGNED NULL,                    -- 套餐额度快照（便于追溯）
  hard_limit BIGINT UNSIGNED NULL,
  UNIQUE KEY uq_usage (tenant_id, meter_code, period_start),
  KEY idx_usage_lookup (tenant_id, meter_code, period_end),
  CONSTRAINT fk_uc_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE
) ENGINE=InnoDB;

-- 可选：用量事件流水（审计/对账）
CREATE TABLE usage_events (
  id BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
  tenant_id BIGINT UNSIGNED NOT NULL,
  meter_code VARCHAR(64) NOT NULL,
  amount INT NOT NULL,
  occurred_at DATETIME(3) NOT NULL,
  metadata JSON,
  KEY idx_ue (tenant_id, occurred_at),
  CONSTRAINT fk_ue_tenant FOREIGN KEY (tenant_id) REFERENCES tenants(id) ON DELETE CASCADE
) ENGINE=InnoDB;
```

> **业务库的所有“租户域”业务表**（如 `projects`, `orders`, `assets`, `jobs`, `webhooks` 等）**必须**包含：
>
> * `tenant_id BIGINT UNSIGNED NOT NULL`
> * 联合索引：`KEY (tenant_id, <常用过滤列>)`
> * 唯一性在租户范围内约束：如 `UNIQUE(tenant_id, project_key)`

---

## 三、数据隔离方案对比（A/B/C）

| 方案    | 描述                                | 优点                        | 缺点                                  | 适用场景             |
| ----- | --------------------------------- | ------------------------- | ----------------------------------- | ---------------- |
| **A** | 共享DB+共享schema；所有表含 `tenant_id`    | 成本低、迁移容易、开发效率高；跨租户运营/分析简单 | 应用侧必须严控“漏 WHERE”；单表体量大需良好索引与归档      | 多数SaaS的默认最佳实践    |
| **B** | 共享DB+多schema（MySQL 中近似多 database） | 逻辑隔离增强；按schema备份          | 上万 schema 的迁移/DDL/连接管理复杂；Knex 迁移要遍历 | 少量租户且强隔离诉求、同一实例  |
| **C** | 独立数据库                             | 隔离最强；可定制RPO/RTO；可独立扩容/合规  | 运维与成本最高；跨租户运营复杂；路由/迁移复杂             | 少量巨型或合规租户（金融/政府） |

**推荐**：**A 为主，保留 C 的升级通道（hybrid）**。为此在 `tenants` 增加 `connection_url` 字段，当不为空时在数据访问层将该租户的 Knex 连接切换到其独库。

---

## 四、租户上下文传递（tenant\_id 的识别与验证）

**识别来源**（按优先级）

1. **JWT/Session 的 `tid` claim**（推荐）；
2. **子域名**：`{slug}.your-saas.com` → 查 `tenants.slug -> id`；
3. **路径前缀**：`/t/:slug/...`；
4. **私有 API** 才允许 `X-Tenant-Id` 头（需同时校验 uid 与 membership）。

**服务端流程**

* 每个请求先经 **Auth & Tenant Middleware**：

  * 解出 `userId`、`tenantId/sl ug`、`role`；
  * 校验 `tenant_members` 是否存在且 `status=active`；
  * 将 `{tenantId, userId, role}` 放入 **AsyncLocalStorage**（ALS），后续所有 DAO/Repo 从 ALS 读取上下文。
* **禁止**前端自行传 `tenant_id` 参与查询；服务端以服务器侧上下文为准，避免 IDOR。

---

## 五、租户级配置管理

* **存储**：

  * 常用 UI 配置（logo/品牌色）可放 `tenants`（列式），
  * 其他功能开关/自定义项放 `tenant_configs(key,value JSON)`。
* **读取**：

  * `getTenantConfig(tenantId, keys[])` → Redis 缓存：`tenant:cfg:{tenantId}:v{version}`；
  * 变更配置时把 `tenants.config_version += 1`，即可**全局失效缓存**。
* **敏感配置**（API Key 等）：使用应用层 KMS 加密后入库（`is_secret=1`）。

---

## 六、跨租户查询防护

1. **强制作用域**：所有 DAO/Repo 必须通过**租户感知的 Knex 包装器**（见代码）构造查询，框架级自动注入 `WHERE tenant_id = ?`；
2. **查询网关**：注册 Knex `query` 事件，若对“租户域表”缺少 `tenant_id` 约束则**拒绝执行**（白名单只允许读系统表/公共表）；
3. **Join 规范**：`JOIN` 另一租户域表时，必须同时要求 `other.tenant_id = ctx.tenantId`；
4. **测试护栏**：在 CI 中做“跨租户污染”单测（同表两条不同 `tenant_id`，确保永不混读）。

> MySQL 8 没有像 Postgres 的 RLS；也可用 **VIEW + WITH CHECK OPTION** 实现只读防护，但写入仍需应用层控制。实战中**应用层强制作用域**可控性更强。

---

## 七、企业级计费模型（套餐、共享配额、用量核销）

* 每租户 1 条**活跃订阅**（`subscriptions`），`plans.limits` & `features` 决定额度与开关；
* **额度核销**：高并发下使用**原子更新**确保不超限（见代码）；
* **按月周期**：`current_period_start/end`，`tenant_usage_counters` 基于此聚合；
* **超额策略**：`soft_limit` 告警，`hard_limit` 拦截；
* **对账**：`usage_events` 做审计与补账；
* 可对接第三方（如 Stripe）做开票/收款（通过 `external_*_id` 字段）。

---

## 八、租户数据备份与恢复（含单租户导出）

* **整库备份**：常规全量 + binlog PITR。
* **单租户导出（逻辑）**：

  * 使用 `mysqldump` 针对每张租户域表加 `--where="tenant_id=123"`：

    ```bash
    mysqldump --single-transaction yourdb projects --where="tenant_id=123" > tenant_123_projects.sql
    ```
  * 或在 Worker 中 `SELECT ... WHERE tenant_id=?` 导出 JSON/CSV 打包到对象存储。
* **单租户恢复**：

  * 恢复到**新租户/沙箱库**，必要时重写 `tenant_id`；
  * 开启事务顺序导入（父表→子表），确保外键一致性；
  * 大租户迁移到独库（C）：先**双写** → 冻结写 → 增量补齐 → 切换路由。

---

## 九、性能优化要点

* **索引**

  * 所有租户域表添加联合索引：`(tenant_id, <常用过滤列>)`；
  * 唯一约束尽可能以 `(tenant_id, ...)` 实现“租户内唯一”；
  * 高频时间轴查询建：`(tenant_id, created_at)`。
* **分区（可选）**

  * 超大表可考虑 **HASH/KEY 分区 by tenant\_id** 或 **RANGE 分区 by created\_at**，但先以索引+归档为主。
* **缓存**

  * Redis 键统一前缀：`tenant:{tenantId}:<domain>:<id>`；
  * 读多写少配置类（logo/feature）强缓存 + 版本号失效；
  * 计数类短 TTL + 后台刷新。
* **限流**

  * `rate:tenant:{tenantId}:{minute}` 滑动窗口，避免单租户突刺影响全局。
* **异步作业**

  * Job payload 必须携带 `tenantId`，Worker 启动“租户上下文”再做查询写入。
* **观测**

  * 日志与指标均打上 `tenant_id` 标签，便于定位与报表。

---

## 十、从单租户平滑迁移到多租户（实操步骤）

> 目标：不停机或最短读写冻结。

**阶段 0：准备**

* 审计所有业务表，列出“租户域表”清单。
* 抽象 DAO/Repo 层，准备“租户作用域 Knex”适配。

**阶段 1：数据结构调整（在线 DDL）**

1. **新增核心表**：`tenants / tenant_members / tenant_configs / plans / subscriptions / tenant_usage_counters`。
2. **业务表加列**：为所有租户域表新增 `tenant_id`，**先允许 NULL**：

   ```sql
   ALTER TABLE projects ADD COLUMN tenant_id BIGINT UNSIGNED NULL, ALGORITHM=INPLACE, LOCK=NONE;
   CREATE INDEX idx_projects_tenant_created ON projects (tenant_id, created_at);
   ```
3. 建立“默认租户”（把现有所有数据视为一个租户）：

   * `INSERT INTO tenants (slug, name) VALUES ('default', 'Default');` → 记录 `defaultTenantId`。
   * 将所有业务表数据 `UPDATE ... SET tenant_id = defaultTenantId;`（分批运行）。

**阶段 2：应用发布（灰度）**
4\. 发布新代码：

* **写入路径**：新建数据必须写入 `tenant_id`；
* **读取路径**：若 `tenant_id` 为空则回退到 `defaultTenantId`（兼容旧数据）。

5. 开启 Auth & Tenant 中间件，但对旧账号一律映射到 `defaultTenantId`。

**阶段 3：收敛**
6\. 数据回填完成后，将各表 `tenant_id` 改为 **NOT NULL**；
7\. 添加/替换**唯一约束**为“租户内唯一”；
8\. 清除兼容分支（不再允许 `tenant_id IS NULL` 读写）。

**阶段 4：启用多租户**
9\. 开放企业注册/邀请；
10\. 逐步将老客户迁入新租户（创建 tenant/member，迁移其数据 `UPDATE ... SET tenant_id=newId WHERE ...`）。
11\. 对超大客户按需启用**独库**（C）：按“**双写→短暂冻结→增量补齐→切换**”流程执行。

---

## 十一、关键代码示例（Knex/Express/Redis/RBAC/Next）

> 下面均为 **TypeScript** 风格的 Node 代码片段（也可用 JS）。请根据实际项目结构调整。

### 11.1 Knex 迁移：核心表（精简版）

```js
// migrations/20251031_core_multitenant.ts
import { Knex } from 'knex';

export async function up(knex: Knex): Promise<void> {
  await knex.schema.createTable('tenants', (t) => {
    t.bigIncrements('id').primary();
    t.string('slug', 63).notNullable().unique();
    t.string('name', 255).notNullable();
    t.enum('status', ['active','suspended','deleted']).notNullable().defaultTo('active');
    t.string('logo_url', 512);
    t.string('brand_primary', 7);
    t.string('brand_secondary', 7);
    t.integer('config_version').notNullable().defaultTo(1);
    t.enum('billing_mode', ['trial','paid','po','internal']).defaultTo('trial');
    t.string('connection_url', 1024);
    t.timestamp('created_at', { precision: 3 }).defaultTo(knex.fn.now(3));
    t.timestamp('updated_at', { precision: 3 }).defaultTo(knex.fn.now(3));
  });

  await knex.schema.createTable('tenant_members', (t) => {
    t.bigIncrements('id').primary();
    t.bigint('tenant_id').unsigned().notNullable().references('tenants.id').onDelete('CASCADE');
    t.bigint('user_id').unsigned().notNullable().references('users.id').onDelete('CASCADE');
    t.enum('role', ['owner','admin','member','viewer']).notNullable().defaultTo('member');
    t.enum('status', ['active','invited','disabled']).notNullable().defaultTo('active');
    t.bigint('invited_by').unsigned().nullable().references('users.id').onDelete('SET NULL');
    t.timestamp('created_at', { precision: 3 }).defaultTo(knex.fn.now(3));
    t.timestamp('updated_at', { precision: 3 }).defaultTo(knex.fn.now(3));
    t.unique(['tenant_id', 'user_id'], { indexName: 'uq_member' });
    t.index(['tenant_id', 'role'], 'idx_member_role');
  });

  await knex.schema.createTable('tenant_configs', (t) => {
    t.bigIncrements('id').primary();
    t.bigint('tenant_id').unsigned().notNullable().references('tenants.id').onDelete('CASCADE');
    t.string('key', 64).notNullable();
    t.json('value').notNullable();
    t.boolean('is_secret').notNullable().defaultTo(false);
    t.integer('version').notNullable().defaultTo(1);
    t.bigint('updated_by').unsigned().nullable().references('users.id').onDelete('SET NULL');
    t.timestamp('created_at', { precision: 3 }).defaultTo(knex.fn.now(3));
    t.timestamp('updated_at', { precision: 3 }).defaultTo(knex.fn.now(3));
    t.unique(['tenant_id', 'key'], { indexName: 'uq_tenant_key' });
  });

  await knex.schema.createTable('plans', (t) => {
    t.bigIncrements('id').primary();
    t.string('code', 64).notNullable().unique();
    t.string('name', 255).notNullable();
    t.enum('periodicity', ['monthly','yearly']).defaultTo('monthly');
    t.integer('price_cents').unsigned().notNullable();
    t.string('currency', 3).notNullable().defaultTo('USD');
    t.json('limits').notNullable();
    t.json('features').notNullable();
    t.timestamp('created_at', { precision: 3 }).defaultTo(knex.fn.now(3));
    t.timestamp('updated_at', { precision: 3 }).defaultTo(knex.fn.now(3));
  });

  await knex.schema.createTable('subscriptions', (t) => {
    t.bigIncrements('id').primary();
    t.bigint('tenant_id').unsigned().notNullable().references('tenants.id').onDelete('CASCADE');
    t.bigint('plan_id').unsigned().notNullable().references('plans.id');
    t.enum('status', ['trialing','active','past_due','canceled']).notNullable();
    t.timestamp('current_period_start', { precision: 3 }).notNullable();
    t.timestamp('current_period_end', { precision: 3 }).notNullable();
    t.boolean('cancel_at_period_end').notNullable().defaultTo(false);
    t.string('external_customer_id', 128);
    t.string('external_subscription_id', 128);
    t.timestamp('created_at', { precision: 3 }).defaultTo(knex.fn.now(3));
    t.timestamp('updated_at', { precision: 3 }).defaultTo(knex.fn.now(3));
    t.index(['tenant_id', 'current_period_end'], 'idx_sub_tenant_period');
    t.index(['external_subscription_id'], 'idx_ext');
  });

  await knex.schema.createTable('tenant_usage_counters', (t) => {
    t.bigIncrements('id').primary();
    t.bigint('tenant_id').unsigned().notNullable().references('tenants.id').onDelete('CASCADE');
    t.string('meter_code', 64).notNullable();
    t.timestamp('period_start', { precision: 3 }).notNullable();
    t.timestamp('period_end',   { precision: 3 }).notNullable();
    t.bigint('used').unsigned().notNullable().defaultTo(0);
    t.bigint('soft_limit').unsigned().nullable();
    t.bigint('hard_limit').unsigned().nullable();
    t.unique(['tenant_id','meter_code','period_start'], { indexName: 'uq_usage' });
    t.index(['tenant_id','meter_code','period_end'], 'idx_usage_lookup');
  });
}

export async function down(knex: Knex): Promise<void> {
  await knex.schema.dropTableIfExists('tenant_usage_counters');
  await knex.schema.dropTableIfExists('subscriptions');
  await knex.schema.dropTableIfExists('plans');
  await knex.schema.dropTableIfExists('tenant_configs');
  await knex.schema.dropTableIfExists('tenant_members');
  await knex.schema.dropTableIfExists('tenants');
}
```

### 11.2 租户上下文中间件（Auth + Tenant + RBAC）

```ts
// src/middleware/tenantContext.ts
import type { Request, Response, NextFunction } from 'express';
import { AsyncLocalStorage } from 'node:async_hooks';
import { getTenantBySlug, getMembership } from '../repos/tenancyRepo';
import { redisClient } from '../infra/redis';

export type TenantContext = {
  tenantId: number;
  userId: number;
  role: 'owner'|'admin'|'member'|'viewer';
};

export const als = new AsyncLocalStorage<TenantContext>();

export async function tenantContext(req: Request, res: Response, next: NextFunction) {
  // 1) 认证（演示用）：从 req.user 取 uid/role，从 Host 或路径取 slug
  const userId = (req as any).user?.id;
  if (!userId) return res.status(401).json({ error: 'Unauthorized' });

  // 从子域或路径解析 slug（根据你的路由策略）
  const slug = (req as any).tenantSlug || parseSlug(req);
  if (!slug) return res.status(400).json({ error: 'Missing tenant slug' });

  // 2) 查租户（缓存）
  const cacheKey = `tenant:slug:${slug}`;
  let tenantId = Number(await redisClient.get(cacheKey));
  if (!tenantId) {
    const tenant = await getTenantBySlug(slug);
    if (!tenant || tenant.status !== 'active') return res.status(403).json({ error: 'Tenant disabled' });
    tenantId = tenant.id;
    await redisClient.set(cacheKey, String(tenantId), { EX: 300 });
  }

  // 3) 校验成员关系（缓存）
  const mKey = `tenant:member:${tenantId}:${userId}`;
  let role = (await redisClient.get(mKey)) as TenantContext['role'] | null;
  if (!role) {
    const m = await getMembership(tenantId, userId);
    if (!m || m.status !== 'active') return res.status(403).json({ error: 'No membership' });
    role = m.role;
    await redisClient.set(mKey, role, { EX: 120 });
  }

  // 4) 注入 ALS
  const ctx: TenantContext = { tenantId, userId, role };
  als.run(ctx, next);
}

function parseSlug(req: Request): string | null {
  // 示例：子域名 acme.app.com or 路径 /t/acme
  const host = req.headers.host || '';
  const [sub] = host.split('.');
  if (process.env.ROOT_DOMAIN && host.endsWith(process.env.ROOT_DOMAIN) && sub) return sub;

  const m = req.path.match(/^\/t\/([^\/]+)/);
  return m ? m[1] : null;
}
```

### 11.3 租户作用域的 Knex 包装（查询强制 WHERE tenant\_id）

```ts
// src/db/tenantKnex.ts
import type { Knex } from 'knex';
import { als } from '../middleware/tenantContext';

// 需要作用域控制的“租户域表”名单（其余表不强制）
const TENANT_SCOPED_TABLES = new Set([
  'projects', 'orders', 'assets', 'jobs', 'webhooks',
  // ...你的业务表
]);

export function tenantScoped(knex: Knex) {
  // 返回一个简化的 table 入口，自动附加 tenant 条件
  function table<TRecord = any, TResult = any>(tableName: string) {
    const qb = knex<TRecord, TResult>(tableName);
    const ctx = als.getStore();
    if (!ctx) throw new Error('No TenantContext');

    if (TENANT_SCOPED_TABLES.has(tableName)) {
      qb.where(`${tableName}.tenant_id`, ctx.tenantId);
    }
    return qb;
  }

  // 保护 JOIN 场景：自动附加 join 表的 tenant_id 条件
  function joinSameTenant(qb: Knex.QueryBuilder, joinTable: string, localKey: string, foreignKey: string) {
    const ctx = als.getStore();
    if (!ctx) throw new Error('No TenantContext');
    if (!TENANT_SCOPED_TABLES.has(joinTable)) return qb.join(joinTable, localKey, foreignKey);
    return qb.join(joinTable, function () {
      this.on(localKey, '=', foreignKey).andOn(`${joinTable}.tenant_id`, '=', ctx.tenantId);
    });
  }

  // 运行前校验：若触发对租户域表的查询但未包含 tenant_id 条件则抛错（双保险）
  knex.on('query', (q) => {
    const sql = (q.sql || '').toLowerCase();
    for (const t of TENANT_SCOPED_TABLES) {
      if (sql.includes(` from ${t} `) || sql.includes(` join ${t} `)) {
        if (!sql.includes(`${t}.tenant_id`)) {
          // 允许一些子句场景略复杂，这里可以更鲁棒地 parse AST；示例为简单守门
          throw new Error(`Unsafe cross-tenant query detected on table ${t}`);
        }
      }
    }
  });

  return { table, joinSameTenant };
}
```

**使用示例：**

```ts
// src/repos/projectRepo.ts
import { tenantScoped } from '../db/tenantKnex';
import knex from '../db/knex';

const tk = tenantScoped(knex);

export async function listProjects() {
  return tk.table('projects').select('*').orderBy('created_at', 'desc').limit(50);
}

export async function createProject(input: { name: string }) {
  const ctx = require('../middleware/tenantContext').als.getStore();
  return tk.table('projects').insert({
    tenant_id: ctx!.tenantId,
    name: input.name
  });
}
```

### 11.4 RBAC 权限检查（简单且可读）

```ts
// src/auth/rbac.ts
import { als } from '../middleware/tenantContext';

type Action =
  | 'tenant:update'
  | 'member:invite'
  | 'member:list'
  | 'project:read'
  | 'project:write'
  | 'billing:view'
  | 'billing:update';

const ROLE_PERMS: Record<string, Action[]> = {
  owner: ['tenant:update','member:invite','member:list','project:read','project:write','billing:view','billing:update'],
  admin: ['tenant:update','member:invite','member:list','project:read','project:write','billing:view','billing:update'],
  member:['project:read','project:write'],
  viewer:['project:read']
};

export function requirePerm(action: Action) {
  return (_req: any, res: any, next: any) => {
    const ctx = als.getStore();
    if (!ctx) return res.status(500).json({ error: 'No context' });
    const allowed = ROLE_PERMS[ctx.role] || [];
    if (!allowed.includes(action)) return res.status(403).json({ error: 'Forbidden' });
    next();
  };
}
```

### 11.5 额度核销（企业共享配额的原子操作）

```ts
// src/billing/usage.ts
import knex from '../db/knex';
import { als } from '../middleware/tenantContext';

export async function tryConsume(meter: string, amount: number) {
  const ctx = als.getStore();
  if (!ctx) throw new Error('No context');

  // 取当前订阅周期
  const sub = await knex('subscriptions')
    .where({ tenant_id: ctx.tenantId })
    .andWhere('status', 'in', ['trialing','active'])
    .orderBy('current_period_end','desc')
    .first();

  if (!sub) throw new Error('No active subscription');

  const { current_period_start, current_period_end, plan_id } = sub;
  const plan = await knex('plans').where({ id: plan_id }).first();
  const limits = plan.limits || {};
  const hardLimit = (limits as any)[`${meter}_hard`] ?? null;
  const softLimit = (limits as any)[`${meter}_soft`] ?? null;

  // 初始化计数器
  await knex('tenant_usage_counters').insert({
    tenant_id: ctx.tenantId,
    meter_code: meter,
    period_start: current_period_start,
    period_end: current_period_end,
    soft_limit: softLimit,
    hard_limit: hardLimit
  }).onConflict(['tenant_id','meter_code','period_start']).ignore();

  // 原子扣减（防竞态超限）
  const updated = await knex('tenant_usage_counters')
    .where({
      tenant_id: ctx.tenantId,
      meter_code: meter,
      period_start: current_period_start
    })
    .andWhere(function () {
      if (hardLimit != null) this.whereRaw('used + ? <= ?', [amount, hardLimit]);
    })
    .update({ used: knex.raw('used + ?', [amount]) });

  if (updated === 0) {
    throw new Error('Quota exceeded'); // 返回 402/429 皆可
  }
}
```

### 11.6 配置读取（Redis 版本化缓存）

```ts
// src/config/tenantConfig.ts
import knex from '../db/knex';
import { redisClient } from '../infra/redis';

export async function getTenantConfig(tenantId: number, keys: string[]) {
  const tenant = await knex('tenants').select(['id','config_version']).where({ id: tenantId }).first();
  if (!tenant) throw new Error('Tenant not found');

  const cacheKey = `tenant:cfg:${tenant.id}:v${tenant.config_version}`;
  const cached = await redisClient.hGetAll(cacheKey);
  let kv: Record<string, any> = {};
  if (Object.keys(cached).length) {
    kv = Object.fromEntries(Object.entries(cached).map(([k, v]) => [k, JSON.parse(v)]));
  } else {
    const rows = await knex('tenant_configs').where({ tenant_id: tenant.id });
    kv = Object.fromEntries(rows.map((r: any) => [r.key, r.value]));
    if (rows.length) {
      const pipe = redisClient.multi();
      for (const [k, v] of Object.entries(kv)) pipe.hSet(cacheKey, k, JSON.stringify(v));
      pipe.expire(cacheKey, 3600);
      await pipe.exec();
    }
  }
  return keys.length ? Object.fromEntries(keys.filter(k => k in kv).map(k => [k, kv[k]])) : kv;
}
```

### 11.7 示例 API 路由（项目列表 & 成员邀请）

```ts
// src/routes/projects.ts
import { Router } from 'express';
import { tenantContext } from '../middleware/tenantContext';
import { requirePerm } from '../auth/rbac';
import { listProjects, createProject } from '../repos/projectRepo';
import { tryConsume } from '../billing/usage';

const r = Router();

r.use(tenantContext);

r.get('/', requirePerm('project:read'), async (_req, res) => {
  const items = await listProjects();
  res.json({ items });
});

r.post('/', requirePerm('project:write'), async (req, res) => {
  // 核销一次额度（例如每创建项目计一次）
  await tryConsume('project_create', 1);
  await createProject({ name: req.body.name });
  res.status(201).end();
});

export default r;
```

### 11.8 Next.js 14：多租户路由与主题注入（示例）

```
app/
  t/[slug]/layout.tsx      // 每租户工作区
  t/[slug]/page.tsx
middleware.ts              // 解析子域 -> 重写到 /t/:slug
```

```ts
// middleware.ts (示例：子域 -> /t/:slug)
import { NextRequest, NextResponse } from 'next/server';

export function middleware(req: NextRequest) {
  const host = req.headers.get('host') || '';
  const root = process.env.ROOT_DOMAIN || 'your-saas.com';
  if (host.endsWith(root)) {
    const sub = host.slice(0, -(root.length + 1));
    if (sub && sub !== 'www') {
      const url = req.nextUrl.clone();
      if (!url.pathname.startsWith(`/t/${sub}`)) {
        url.pathname = `/t/${sub}${url.pathname}`;
        return NextResponse.rewrite(url);
      }
    }
  }
  return NextResponse.next();
}
```

```tsx
// app/t/[slug]/layout.tsx
import type { ReactNode } from 'react';
import { getTenantTheme } from '@/lib/tenantTheme'; // 服务端读取 getTenantConfig

export default async function TenantLayout({ children, params }: { children: ReactNode, params: { slug: string }}) {
  const theme = await getTenantTheme(params.slug);
  return (
    <html>
      <body style={{ ['--brand-primary' as any]: theme.primary, ['--brand-secondary' as any]: theme.secondary }}>
        <header><img src={theme.logoUrl} alt="logo" height={24}/></header>
        {children}
      </body>
    </html>
  );
}
```

---

## 十二、缓存键与索引策略（速查）

* Redis：

  * 配置：`tenant:cfg:{tenantId}:v{version}`（hash）
  * 列表页缓存：`tenant:{tenantId}:projects:list:{hash(filters)}`（短 TTL）
  * 成员角色：`tenant:member:{tenantId}:{userId}`（120s）
* MySQL 索引：

  * `KEY (tenant_id, created_at)`、`KEY (tenant_id, status)`
  * 唯一性：`UNIQUE (tenant_id, external_key)`
  * 大表定期归档：`created_at < now() - 180d` 转冷数据表/对象存储。

---

## 十三、安全与合规提示

* **永远不要**信任前端传来的 `tenant_id`；
* 后台任务/回调（webhook、队列）**必须**带上 `tenantId`，Worker 启动时注入 ALS；
* 审计日志 `audit_logs`（包含 actor、resource、action、tenant\_id）便于企业合规；
* 若有“数据驻留/加密”要求：为敏感列启用**每租户密钥**加密（Envelope + KMS 参考）；
* 为企业客户增加 SSO（SAML/OIDC）与 SCIM（预置成员与停用同步）。

---

## 十四、你问我答（对应需求列表）

1. **企业注册**：创建 `tenants` 记录 + `tenant_members(owner)`；
2. **邀请成员**：写 `tenant_invitations`，接受后写 `tenant_members`；
3. **数据隔离**：所有租户域表含 `tenant_id`；通过 **Tenant-Scoped Knex** 强制 WHERE；
4. **自定义配置**：`tenants` + `tenant_configs` + Redis 版本化缓存；
5. **企业计费**：`plans + subscriptions + tenant_usage_counters(+events)`；
6. **RBAC**：`tenant_members.role` + `requirePerm` 中间件；
7. **备份恢复**：整库 + 单租户逻辑导出（`--where tenant_id=...`）；
8. **性能**：复合索引（`tenant_id` 放首列）、缓存前缀、限流与异步化；
9. **迁移**：在线加列→回填→应用灰度→收敛 NOT NULL→开放新租户→（可选）大租户独库；
10. **代码**：上文提供 Knex 迁移、上下文中间件、RBAC、查询封装、配额核销、Next SSR。

---

## 十五、可选的增强（后续演进）

* **混合路由**：根据 `tenants.connection_url` 为特定租户创建专属 Knex 连接池（C 方案），其余走默认池；
* **资源服务**：S3/OSS 的对象键加前缀 `tenant/{tenantId}/...`；
* **行级加密**：`AES_GCM` + per-tenant key（应用层封装）；
* **视图/存储过程**：特定报表可用 VIEW 固化过滤逻辑；
* **数据网关**：引入 SQL 审计/防火墙或在 ORM 层做 AST 检查。

---

如果你希望，我可以把上述迁移脚本与示例服务路由整理成一个最小可运行样例仓库结构（包含 Docker Compose 的 MySQL/Redis、本地演示的 Next.js 与 Express 网关），方便你直接启动联调。
