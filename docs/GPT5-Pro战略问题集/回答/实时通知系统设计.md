下面给出一套适配你们 **Next.js 14 + Express.js** 的实时通知系统完整方案，涵盖技术选型、在腾讯云（CLB/负载均衡）多实例部署、离线补发、消息持久化、性能优化，以及可直接落地的前后端代码示例与架构图。内容较长，但你可以直接拷贝代码到项目中逐步落地。

---

## 0. 结论先行（推荐组合）

* **主通道**：`WebSocket（Socket.IO）` —— 满足任务状态、聊天、工单客服等**双向**实时通信；用 **Redis Adapter** 做跨实例广播；不强依赖 sticky session。([socket.io][1])
* **备通道**：`SSE`（仅下行）—— 用于**浏览器受限**或反向代理不允许 WebSocket 的环境下，保障“通知”至少可达。([MDN Web Docs][2])
* **兜底**：`短轮询`（退化方案）—— 仅在 WS/SSE 都不可用时启用。
* **第三方**：移动端/APP 推送或未来客服可考虑 **腾讯云 IM（含客服/会话/离线漫游）** 或 **极光推送（JPush）**，作为“端外推送”补充，而不是取代站内实时通道。([Tencent Cloud][3])

> **腾讯云是否支持 WebSocket？** 支持。CLB（负载均衡）**默认支持 WS/WSS**，可在七层监听器开启，且可通过“七层个性化配置”调整空闲/读超时（如 `proxy_read_timeout`、`keepalive_timeout` 等）。([Tencent Cloud][4])

---

## 1) 技术选型对比（WebSocket / SSE / 轮询 / 第三方）

| 维度         | WebSocket（Socket.IO） | SSE（EventSource）              | 轮询        | 第三方（腾讯云IM/极光）    |
| ---------- | -------------------- | ----------------------------- | --------- | ---------------- |
| 通道方向       | 双向                   | 单向（服务→客户端）                    | 单向        | 多终端（含移动端通道）      |
| 复杂度        | ☆☆☆（中）               | ☆☆（低）                         | ☆（低）      | ☆☆☆☆（高，SDK+对接）   |
| 多实例        | Redis Adapter 横向扩展   | 无需粘性，天然可横向（HTTP）              | 无需粘性      | 自带集群能力           |
| 离线补发       | 需自建持久化/补发            | 利用 `Last-Event-ID` + 服务端游标可补发 | 由API与游标控制 | 服务内置漫游/离线（付费/配额） |
| 聊天/客服      | ✅                    | ❌                             | ❌         | ✅                |
| 任务/公告/配额提醒 | ✅                    | ✅                             | ✅         | ✅                |
| 典型问题       | LB/代理空闲超时、心跳开销       | 浏览器仅下行、鉴权不便（HTTP Header限制）    | 时延高、请求放大  | 成本/厂商绑定          |
| 结论         | **推荐主通道**            | **推荐备通道**                     | 兜底        | 作为端外推送/客服增补      |

> SSE 的 `Last-Event-ID` 能帮助断线后续传，浏览器会在重连时带上该头部（实现有差异，服务端保守实现为佳）。([html.spec.whatwg.org][5])

---

## 2) 多实例 WebSocket 架构（Redis Pub/Sub，是否需要 Sticky Session？）

* **核心**：所有后端实例上的 Socket.IO 通过 **Redis Adapter** 互联。消息在本机直发给本实例连接，同时**发布到 Redis Channel**，其他实例订阅后转发给其本地连接，确保“用户连在 A、消息产生于 B 也能送达”。**无需依赖粘性会话**（sticky），但如开启 HTTP 长轮询回退，则官方建议对长轮询请求启用 sticky。([socket.io][1])
* **腾讯云 CLB**：默认支持 WS/WSS；对于长连接空闲可通过“七层个性化配置”提升 `keepalive_timeout/proxy_read_timeout`。([Tencent Cloud][4])

**部署视图（Mermaid）**

```mermaid
flowchart LR
  subgraph Client["浏览器 (Next.js 14)"]
    A1[WS 主通道]:::c
    A2[SSE 备通道]:::c
  end

  subgraph CLB["腾讯云 CLB(HTTP/HTTPS/TCP)"]
  end

  subgraph NodePool["Express + Socket.IO (PM2多实例)"]
    N1[实例 #1]
    N2[实例 #2]
    N3[实例 #3]
  end

  subgraph Infra["基础设施"]
    R[(Redis Cluster)\nPub/Sub + KV + ZSET/STREAM]
    M[(MySQL)\n通知/收据/出站箱]
  end

  Client --> CLB --> N1 & N2 & N3
  N1 <---> R
  N2 <---> R
  N3 <---> R
  N1 <---> M
  N2 <---> M
  N3 <---> M

  classDef c fill:#eef,stroke:#99f,stroke-width:1px
```

---

## 3) 消息数据模型（MySQL + Redis）

> 建议 **UUIDv7** 作为主键，天然时间有序，利于“按时间补拉”和索引局部性（见 RFC 9562 及社区实践）。([IETF][6])

**表 1：notification\_message（消息体）**

| 字段                        | 类型                                                                    | 说明                   |
| ------------------------- | --------------------------------------------------------------------- | -------------------- |
| id                        | CHAR(36) (UUIDv7) PK                                                  | 消息ID                 |
| scope                     | ENUM('user','tenant','broadcast','segment')                           | 推送范围                 |
| type                      | ENUM('task','quota','announcement','commission','order\_paid','chat') | 业务类型                 |
| title                     | VARCHAR(200)                                                          | 标题                   |
| body                      | TEXT                                                                  | 正文（可 markdown）       |
| data                      | JSON                                                                  | 业务payload（任务ID、订单号等） |
| priority                  | TINYINT                                                               | 优先级（10=紧急、5=普通、1=低）  |
| dedupe\_key               | VARCHAR(128) UNIQUE                                                   | 幂等去重键                |
| created\_at / expires\_at | DATETIME                                                              | 创建/过期                |

**表 2：notification\_inbox（用户收件箱，**一行/人/消息**）**

| 字段                       | 类型                                     | 说明                             |
| ------------------------ | -------------------------------------- | ------------------------------ |
| id                       | CHAR(36) PK (UUIDv7)                   |                                |
| message\_id              | CHAR(36) FK → notification\_message.id |                                |
| user\_id                 | BIGINT                                 | 收件人                            |
| status                   | ENUM('queued','delivered','read')      | 投递/阅读状态                        |
| delivered\_at / read\_at | DATETIME                               |                                |
| created\_at              | DATETIME                               | 索引（user\_id, created\_at DESC） |

**表 3：notification\_outbox（出站箱 / 可靠事件）**
把业务事件与消息入库放在同一事务，异步投递（outbox pattern）。

| 字段          | 类型          | 说明                 |
| ----------- | ----------- | ------------------ |
| id          | CHAR(36) PK |                    |
| event\_type | VARCHAR(50) | 如 `task.completed` |
| payload     | JSON        |                    |
| processed   | TINYINT     | 是否已投递              |
| created\_at | DATETIME    |                    |

**Redis 用途**

* `notif:pending:{userId}`（ZSET，score=时间或优先级）——**在线优先队列**；
* `notif:dedupe:{dedupeKey}`（SET NX + TTL）——**幂等**；
* 可选：使用 **Redis Streams**（`XADD/XREADGROUP`）按用户分组做可确认的投递流水（更强的“至少一次”与回放能力）。([Redis][7])

> Redis Sorted Set 非常适合实现优先级队列/定序。([Redis][8])

---

## 4) 断线重连与离线补发

* **客户端**持久化 `lastAckId`（UUIDv7）到 `localStorage`。
* **握手时**把 `lastAckId` 放到查询参数或认证载荷；
* **服务端**按 `(user_id, id > lastAckId)` 从 `notification_inbox` 拉取，按 `created_at ASC` 批量补发；
* **客户端**对每条消息 `ack`（或做批量 ack：`ackRange`），服务端更新 `status=delivered` 与 `delivered_at`。
* **SSE** 备通道可利用 **`Last-Event-ID`** 自动续传（仍建议服务器端以 `lastAckId` 为准，更可控）。([html.spec.whatwg.org][5])

---

## 5) 消息优先级 & 去重

* **优先级**：消息写入时落 `priority`。实时推送回路中，先从 `notif:pending:{userId}` ZSET 按 `priority desc, time asc` 出队。
* **去重**：下游触发推送前先 `SET NX notif:dedupe:{dedupeKey}`；DB 层 `dedupe_key` 也建唯一索引，双保险。

---

## 6) 性能与扩展（10万在线）

* **横向扩展**：多实例 + **Socket.IO Redis Adapter**；
* **心跳**：将 `pingInterval` 设置 **20–30s** 区间（默认 25s），`pingTimeout` 60s+，以抵御代理/浏览器节流；CLB 七层可适度提高 `keepalive_timeout/proxy_read_timeout`。([socket.io][9])
* **压缩**：谨慎开启 `perMessageDeflate`，官方提示其带来**明显 CPU/内存开销**，建议仅对大消息启用阈值压缩（如 > 1KB）。([socket.io][10])
* **批量投递**：将 T 内（如 100–300ms）产生的多条低优先消息合并后再发，减少帧数；
* **连接管理**：限制每用户并发连接数（基于 `userId`）以防 N Tab 风暴；
* **观测**：Prometheus 指标（连接数、发送速率、补发耗时、失败率）；慢查询索引 `(user_id, created_at)`。

---

## 7) 后端：Express + Socket.IO（含 Redis 适配、鉴权、补发、ACK）

> 下述为 TypeScript 版最小可运行骨架，已集成 Redis Adapter（ioredis）、JWT 鉴权、离线补发、批量 ACK、幂等与优先队列。

```ts
// src/server.ts
import http from 'http';
import express from 'express';
import { Server } from 'socket.io';
import { createAdapter } from '@socket.io/redis-adapter';
import { Cluster, Redis } from 'ioredis';
import jwt from 'jsonwebtoken';
import bodyParser from 'body-parser';
import mysql from 'mysql2/promise';

const app = express();
app.use(bodyParser.json());

const server = http.createServer(app);

// === Socket.IO with Redis adapter ===
const io = new Server(server, {
  cors: { origin: [/^https?:\/\/localhost:\d+$/, /\.yourdomain\.com$/], credentials: true },
  transports: ['websocket', 'polling'],   // 允许长轮询回退
  pingInterval: 25000,                    // 25s
  pingTimeout: 60000,                     // 60s
  perMessageDeflate: { threshold: 1024 }, // >1KB 才压缩（谨慎开启）
});

const redis = new Cluster([
  { host: process.env.REDIS_1!, port: 6379 },
  { host: process.env.REDIS_2!, port: 6379 },
  { host: process.env.REDIS_3!, port: 6379 },
]);
const sub = new Cluster([
  { host: process.env.REDIS_1!, port: 6379 },
  { host: process.env.REDIS_2!, port: 6379 },
  { host: process.env.REDIS_3!, port: 6379 },
]);

io.adapter(createAdapter(redis as any, sub as any)); // socket.io Redis adapter

// === MySQL pool ===
const db = mysql.createPool({
  uri: process.env.MYSQL_URI!,
  connectionLimit: 10,
});

// === 工具：推送到用户房间 ===
function roomOf(userId: string | number) {
  return `user:${userId}`;
}

// === Socket 鉴权（握手 token -> userId）===
io.use(async (socket, next) => {
  try {
    const token = socket.handshake.auth?.token || socket.handshake.query?.token;
    if (!token) return next(new Error('unauthorized'));
    const payload = jwt.verify(String(token), process.env.JWT_SECRET!) as { uid: string; lastAckId?: string };
    (socket.data as any).userId = payload.uid;
    (socket.data as any).lastAckId = payload.lastAckId;
    next();
  } catch (e) {
    next(new Error('unauthorized'));
  }
});

io.on('connection', async (socket) => {
  const { userId, lastAckId } = socket.data as { userId: string; lastAckId?: string };
  await socket.join(roomOf(userId));

  // 1) 离线补发
  if (lastAckId) {
    const [rows] = await db.query(
      `SELECT i.id, m.type, m.title, m.body, m.data, m.priority, i.created_at
       FROM notification_inbox i 
       JOIN notification_message m ON i.message_id = m.id
       WHERE i.user_id = ? AND i.id > ? 
       ORDER BY i.created_at ASC LIMIT 200`,
      [userId, lastAckId]
    );
    (rows as any[]).forEach(msg => {
      socket.emit('notification', { ...msg });
    });
  } else {
    const [rows] = await db.query(
      `SELECT i.id, m.type, m.title, m.body, m.data, m.priority, i.created_at
       FROM notification_inbox i 
       JOIN notification_message m ON i.message_id = m.id
       WHERE i.user_id = ? AND i.status = 'queued'
       ORDER BY i.created_at ASC LIMIT 200`,
      [userId]
    );
    (rows as any[]).forEach(msg => socket.emit('notification', { ...msg }));
  }

  // 2) 批量 ACK
  socket.on('notify:ack', async (payload: { ids: string[] }) => {
    if (!payload?.ids?.length) return;
    const ids = payload.ids;
    await db.query(
      `UPDATE notification_inbox SET status='delivered', delivered_at=NOW()
       WHERE user_id=? AND id IN (?)`, [userId, ids]
    );
  });

  socket.on('disconnect', () => {
    // 可记录 last_seen / 清理本地状态
  });
});

// === 幂等去重（Redis SET NX）===
async function setOnce(dedupeKey: string, ttlSec = 600): Promise<boolean> {
  const res = await (redis as any).set(`notif:dedupe:${dedupeKey}`, '1', 'NX', 'EX', ttlSec);
  return res === 'OK';
}

// === 推送 API（供业务事件触发）===
app.post('/api/notify/:kind', async (req, res) => {
  const { kind } = req.params; // task/quota/announcement/commission/order_paid/chat
  const { userId, title, body, data, priority = 5, dedupeKey } = req.body;

  if (dedupeKey && !(await setOnce(dedupeKey))) {
    return res.status(200).json({ ok: true, deduped: true });
  }

  // 1) 写消息体 + inbox（出站箱省略）
  const conn = await db.getConnection();
  try {
    await conn.beginTransaction();
    const [msgRes] = await conn.query(
      `INSERT INTO notification_message (id, scope, type, title, body, data, priority, dedupe_key, created_at)
       VALUES (UUID(), 'user', ?, ?, ?, ?, ?, ?, NOW())`,
      [kind, title, body, JSON.stringify(data || {}), priority, dedupeKey || null]
    );
    // MySQL 不便返回 UUID，简单再 select last_insert/或使用 UUID() 变量；真实项目推荐 UUIDv7 由应用生成
    const [[message]]: any = await conn.query(`SELECT id FROM notification_message ORDER BY created_at DESC LIMIT 1`);
    await conn.query(
      `INSERT INTO notification_inbox (id, message_id, user_id, status, created_at)
       VALUES (UUID(), ?, ?, 'queued', NOW())`,
      [message.id, userId]
    );
    await conn.commit();

    // 2) 在线实时投递
    io.to(roomOf(userId)).emit('notification', {
      id: message.id, type: kind, title, body, data, priority, created_at: new Date().toISOString()
    });

    // 3) 放入待处理优先队列（离线/后续补发）
    await (redis as any).zadd(`notif:pending:${userId}`, Date.now(), message.id);

    res.json({ ok: true, messageId: message.id });
  } catch (e) {
    await conn.rollback();
    res.status(500).json({ ok: false, error: String(e) });
  } finally {
    conn.release();
  }
});

// === SSE 备通道（仅通知）===
app.get('/api/sse', async (req, res) => {
  // TODO: 与 WS 相同的鉴权与 lastAckId 逻辑
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    Connection: 'keep-alive',
  });
  res.write(`event: ping\ndata: ok\n\n`);
  // 实际项目：订阅 Redis pub/sub 或轮询 DB/Redis pending，使用 id: <uuid> + data: <json> 推送
});

server.listen(process.env.PORT || 3001, () => {
  console.log('Realtime server listening…');
});
```

> 多实例扩展：上面的 **Redis Adapter** 就是关键。官方文档说明跨进程/跨机器时，所有多播包会同时在 Redis Channel 转发给其它节点。([socket.io][1])
> 若启用 **HTTP 长轮询** 回退，官方建议**启用 sticky** 以保证同一 Socket.IO 会话关联的请求落在同一实例（WebSocket 升级后长期连接则不要求）。([socket.io][11])

---

## 8) 前端（Next.js 14）WebSocket Hook（自动重连、心跳、ACK、SSE 备通道）

```ts
// app/hooks/useRealtime.ts
'use client';

import { useEffect, useRef, useState, useCallback } from 'react';
import { io, Socket } from 'socket.io-client';

type Notification = {
  id: string; type: string;
  title: string; body?: string;
  data?: any; priority?: number; created_at?: string;
};

// 读/写 lastAckId
const ACK_KEY = 'realtime:lastAckId';
const getLastAckId = () => (typeof window !== 'undefined' ? localStorage.getItem(ACK_KEY) || '' : '');
const setLastAckId = (id: string) => localStorage.setItem(ACK_KEY, id);

export function useRealtime(token: string) {
  const [connected, setConnected] = useState(false);
  const [queue, setQueue] = useState<Notification[]>([]);
  const socketRef = useRef<Socket | null>(null);
  const ackBuffer = useRef<string[]>([]);
  const flushTimer = useRef<number | null>(null);

  // 批量 ACK
  const scheduleFlushAck = useCallback(() => {
    if (flushTimer.current) return;
    flushTimer.current = window.setTimeout(() => {
      if (socketRef.current && ackBuffer.current.length) {
        const ids = Array.from(new Set(ackBuffer.current.splice(0)));
        socketRef.current.emit('notify:ack', { ids });
        // 记录最新 ack id（假定消息按时间有序）
        setLastAckId(ids[ids.length - 1]!);
      }
      flushTimer.current && clearTimeout(flushTimer.current);
      flushTimer.current = null;
    }, 300);
  }, []);

  useEffect(() => {
    if (!token) return;

    const socket = io(process.env.NEXT_PUBLIC_RT_URL!, {
      transports: ['websocket', 'polling'],
      auth: { token, lastAckId: getLastAckId() },
      reconnection: true,
      reconnectionAttempts: Infinity,
      reconnectionDelay: 500,
      reconnectionDelayMax: 8000,
      timeout: 20000,
    });

    socketRef.current = socket;

    socket.on('connect', () => setConnected(true));
    socket.on('disconnect', () => setConnected(false));

    socket.on('notification', (msg: Notification) => {
      setQueue((q) => [...q, msg]);
      ackBuffer.current.push(msg.id);
      scheduleFlushAck();
    });

    return () => {
      socket.removeAllListeners();
      socket.disconnect();
    };
  }, [token, scheduleFlushAck]);

  // SSE 备通道（若 WS 长期失败可挂载）
  const startSSEFallback = useCallback(() => {
    const url = `${process.env.NEXT_PUBLIC_RT_ORIGIN}/api/sse?token=${encodeURIComponent(token)}&lastAckId=${encodeURIComponent(getLastAckId())}`;
    const es = new EventSource(url, { withCredentials: true });
    es.onmessage = (e) => {
      const msg: Notification = JSON.parse(e.data);
      setQueue((q) => [...q, msg]);
      ackBuffer.current.push(msg.id);
      scheduleFlushAck();
    };
    es.onerror = () => {
      // 自动重连由 EventSource 内部处理，必要时可重建
    };
    return () => es.close();
  }, [token, scheduleFlushAck]);

  return { connected, queue, startSSEFallback };
}
```

> SSE 的使用方式与浏览器 `EventSource` 一致。其“自动重连 + Last-Event-ID”是在 HTTP 标准中定义的，但实际实现因浏览器或 polyfill 而异，服务端仍应以 `lastAckId` 为权威。([html.spec.whatwg.org][5])

---

## 9) 消息触发 API 设计（示例）

统一使用 `POST /api/notify/:kind`，由业务服务或异步处理器调用：

* `POST /api/notify/task`：任务状态（processing→completed/failed）
* `POST /api/notify/quota`：配额<10% 预警
* `POST /api/notify/announcement`：系统公告（广播/分群）
* `POST /api/notify/commission`：分销佣金到账
* `POST /api/notify/order_paid`：订单支付成功（从支付回调中触发）
* `POST /api/notify/chat`：客服消息

每个请求体统一：`{ userId, title, body, data, priority, dedupeKey }`。
**公告（broadcast/segment）**：可以先写 `notification_message(scope='broadcast')`，再由后台 Job 进行**扇出**写入 `notification_inbox`（或按需“读时扇出”）。

---

## 10) 断线 & 离线消息补发策略（细则）

1. **客户端**持久化 `lastAckId`；
2. **握手**时携带，服务端在 `notification_inbox` 里 `WHERE id > lastAckId` 拉取；
3. **ACK**：客户端 200–300ms 合并一次 `notify:ack`；
4. **服务端**更新 `delivered_at`；
5. **SSE** 重连：依靠 `Last-Event-ID` 与请求参数 `lastAckId` 双渠道校准。([html.spec.whatwg.org][5])

---

## 11) 配额预警、分销佣金、订单支付

* **配额预警**：在配额写操作处写一条 “quota.low” 事件到 `notification_outbox`（阈值<10%触发），由异步 worker 消费并调用 `/api/notify/quota`。
* **分销佣金/订单支付**：从支付/结算回调（Webhook）落地**消息体 + inbox**，再 emit。

---

## 12) 消息去重与幂等

* `dedupe_key` 唯一索引 + Redis `SETNX` 双重保证；
* 以**业务主键 + 事件类型 + 时间片**拼接成 `dedupe_key`（比如 `order:123:paid`）。

---

## 13) Next.js 端：通知 UI（极简 Toast + 列表）

```tsx
// app/notifications/RealtimeToaster.tsx
'use client';
import { useRealtime } from '@/app/hooks/useRealtime';
import { useEffect } from 'react';

export default function RealtimeToaster({ token }: { token: string }) {
  const { connected, queue, startSSEFallback } = useRealtime(token);

  useEffect(() => {
    // WS 连接长期失败时启动 SSE 备份
    let stop: (() => void) | undefined;
    const timer = setTimeout(() => {
      if (!connected) stop = startSSEFallback();
    }, 5000);
    return () => { clearTimeout(timer); stop?.(); };
  }, [connected, startSSEFallback]);

  return (
    <div className="fixed right-4 bottom-4 space-y-2 z-50">
      {!connected && <div className="bg-yellow-100 text-yellow-900 px-3 py-2 rounded">正在尝试重连…</div>}
      {queue.slice(-5).map((n) => (
        <div key={n.id} className="bg-white shadow rounded px-3 py-2 w-80">
          <div className="text-sm font-medium">{n.title}</div>
          {n.body && <div className="text-xs text-gray-600 mt-1">{n.body}</div>}
        </div>
      ))}
    </div>
  );
}
```

---

## 14) 负载均衡 & 腾讯云配置要点

* **CLB 支持 WS/WSS**，默认开启，可结合 **证书服务**做 WSS；空闲超时与七层个性化配置（`proxy_read_timeout`、`keepalive_timeout`）可调。([Tencent Cloud][4])
* **会话保持（Sticky）**：

  * **WebSocket** 一旦升级为长连接，不依赖 sticky；
  * **启用长轮询回退** 时，官方文档建议**开启 sticky**（Cookie/源 IP/hash）以免多请求分配到不同实例。([socket.io][11])
* **心跳**：Socket.IO 心跳基于 `pingInterval/pingTimeout`，默认 25s/20–60s。适当调大 `pingTimeout` 抗前端后台节流。([socket.io][9])

---

## 15) 在线客服（未来扩展）

* 继续沿用 **Socket.IO**，创建 `/chat` namespace：

  * `room=chat:ticket:{id}`；
  * 历史消息落 `chat_messages`（可与 `notification_message` 并行）。
* 若需要**多终端（App/小程序）**与**超大群/客服工作台**：考虑 **腾讯云 IM（含 Desk/客服、消息漫游、离线推送）** 作为 **增量能力**，与站内 WS 保持并行。([Tencent Cloud][3])

---

## 16) 监控与告警（建议）

* 指标：`sockets_connected`、`notifications_sent_total`、`ack_latency_ms`、`redis_pubsub_latency`、`db_select_95p_ms`；
* 日志：对关键类型（支付、佣金）写审计日志；
* 压测：以 1x/5x/10x 阶段压测消息速率与连接上限，验证 Redis/DB 瓶颈。

---

## 附：MySQL 建表 SQL（简化版）

```sql
CREATE TABLE notification_message (
  id CHAR(36) PRIMARY KEY,
  scope ENUM('user','tenant','broadcast','segment') NOT NULL,
  type ENUM('task','quota','announcement','commission','order_paid','chat') NOT NULL,
  title VARCHAR(200) NOT NULL,
  body TEXT NULL,
  data JSON NULL,
  priority TINYINT NOT NULL DEFAULT 5,
  dedupe_key VARCHAR(128) UNIQUE,
  created_at DATETIME NOT NULL,
  expires_at DATETIME NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE notification_inbox (
  id CHAR(36) PRIMARY KEY,
  message_id CHAR(36) NOT NULL,
  user_id BIGINT NOT NULL,
  status ENUM('queued','delivered','read') NOT NULL DEFAULT 'queued',
  delivered_at DATETIME NULL,
  read_at DATETIME NULL,
  created_at DATETIME NOT NULL,
  INDEX idx_user_created (user_id, created_at DESC),
  INDEX idx_user_status (user_id, status, created_at),
  CONSTRAINT fk_inbox_msg FOREIGN KEY (message_id) REFERENCES notification_message(id)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

CREATE TABLE notification_outbox (
  id CHAR(36) PRIMARY KEY,
  event_type VARCHAR(50) NOT NULL,
  payload JSON NOT NULL,
  processed TINYINT NOT NULL DEFAULT 0,
  created_at DATETIME NOT NULL,
  INDEX idx_processed (processed, created_at)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;
```

---

## 参考与依据

* **腾讯云 CLB**：默认支持 WS/WSS、如何开启、超时/七层个性化配置、会话保持说明。([Tencent Cloud][4])
* **Socket.IO 横向扩展 / Redis Adapter / Sticky 建议**。([socket.io][1])
* **SSE（MDN/WHATWG）**：一端推送、重连与 Last-Event-ID。([MDN Web Docs][2])
* **Redis 数据结构**：Streams（XADD/XREADGROUP）、Sorted Set 优先队列。([Redis][7])
* **心跳/压缩性能提示**（Socket.IO 文档）。([socket.io][9])
* **UUIDv7**（RFC 与实践）——用于时间有序主键、离线补拉。([IETF][6])
* **第三方服务**（腾讯云 IM、极光推送）。([Tencent Cloud][3])

---

### 你可以立即落地的步骤清单

1. 在腾讯云 **CLB** 创建 HTTPS/WS 监听器，必要时按文档调大 `keepalive_timeout/proxy_read_timeout`；证书放到 CLB。([Tencent Cloud][12])
2. 在后端接入 **Socket.IO + Redis Adapter**（上文 `server.ts`）。
3. 新建 **MySQL 表**（上文 DDL）。
4. 在 Next.js 注入 `RealtimeToaster`，传入登录后获取的 **JWT token**。
5. 在业务节点（任务完成、配额写操作、支付回调）调用 `/api/notify/:kind`。
6. 持续补齐：**批量 ACK**、**公告扇出 Job**、**SSE 备通道**完善、**监控**与 **压测**。

如需，我可以把以上后端代码拆成模块（鉴权中间件、投递器、补发器、公告扇出 Job）并增加单元测试样例。

[1]: https://socket.io/docs/v4/redis-adapter/?utm_source=chatgpt.com "Redis adapter - Socket.IO"
[2]: https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events?utm_source=chatgpt.com "Using server-sent events - Web APIs | MDN"
[3]: https://cloud.tencent.com/product/im?utm_source=chatgpt.com "即时通信_免费即时通信_即时通信价格 - 腾讯云"
[4]: https://cloud.tencent.com/document/product/214/15186?utm_source=chatgpt.com "负载均衡 WS/WSS 协议支持相关_腾讯云"
[5]: https://html.spec.whatwg.org/multipage/server-sent-events.html?utm_source=chatgpt.com "HTML Standard - WHATWG"
[6]: https://www.ietf.org/rfc/rfc9562.pdf?utm_source=chatgpt.com "RFC 9562: Universally Unique IDentifiers (UUIDs)"
[7]: https://redis.io/docs/latest/develop/data-types/streams/?utm_source=chatgpt.com "Redis Streams | Docs"
[8]: https://redis.io/docs/latest/develop/data-types/sorted-sets/?utm_source=chatgpt.com "Redis sorted sets | Docs"
[9]: https://socket.io/docs/v4/engine-io-protocol/?utm_source=chatgpt.com "The Engine.IO protocol - Socket.IO"
[10]: https://socket.io/docs/v4/server-options/?utm_source=chatgpt.com "Server options - Socket.IO"
[11]: https://socket.io/docs/v4/using-multiple-nodes/?utm_source=chatgpt.com "Using multiple nodes - Socket.IO"
[12]: https://cloud.tencent.com/document/product/214/15171?utm_source=chatgpt.com "负载均衡 七层个性化配置_腾讯云"
