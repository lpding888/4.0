下面是一套**工业级、可扩展、易维护**的前端架构设计与落地方案，完整覆盖你提出的 6 个问题，并提供可运行的 TypeScript 代码骨架与迁移路径。所有示例均基于 **Next.js 14 App Router + TypeScript 严格模式 + Ant Design 5 + Zustand + axios**，并**推荐引入 TanStack Query（React Query）管理“服务端状态”**，Zustand 专注“客户端状态”（权限、UI 偏好等）。

---

## 一、整体架构设计（回答问题1）

### 1) 目录结构（树形图）

```
src
├─ app
│  ├─ (public)                      # 对外公开区（无需登录）
│  │  ├─ login
│  │  │  └─ page.tsx               # 登录页（Server + Client 容器分层）
│  │  └─ pricing
│  │     └─ page.tsx
│  ├─ (dashboard)                   # 登录后用户区（含工作台/素材库/代理/个人中心）
│  │  ├─ layout.tsx                 # 布局（受保护区，含<RequireAuth>）
│  │  ├─ page.tsx                   # 仪表盘
│  │  ├─ workbench
│  │  │  └─ page.tsx                # AI 功能工作台
│  │  ├─ library
│  │  │  └─ page.tsx                # 素材库
│  │  ├─ affiliate
│  │  │  └─ page.tsx                # 分销中心（代理权限）
│  │  └─ account
│  │     └─ page.tsx
│  ├─ admin
│  │  ├─ layout.tsx                 # 管理后台布局（管理员权限）
│  │  ├─ users
│  │  │  └─ page.tsx                # 用户管理（表格示例）
│  │  ├─ orders
│  │  │  └─ page.tsx
│  │  ├─ tasks
│  │  │  └─ page.tsx
│  │  └─ features
│  │     └─ page.tsx
│  ├─ api                           # （可选）Next Route Handlers 代理（如需 SSR）
│  ├─ layout.tsx                    # 根布局（主题/QueryClient/Zustand Provider）
│  └─ page.tsx                      # 首页（营销/引导）
│
├─ components
│  ├─ layout
│  │  ├─ AppShell.tsx               # 通用应用壳（侧边栏/顶部栏）
│  │  └─ PageHeader.tsx
│  ├─ feature
│  │  ├─ FeatureCard.tsx            # 功能卡片（数据驱动）
│  │  └─ FeatureGrid.tsx            # 功能栅格（数据驱动）
│  ├─ forms
│  │  ├─ DynamicForm.tsx            # 动态表单引擎
│  │  └─ fields                     # 字段组件注册表
│  │     ├─ TextField.tsx
│  │     ├─ NumberField.tsx
│  │     ├─ EnumField.tsx
│  │     ├─ ImageUploadField.tsx
│  │     └─ VideoUploadField.tsx
│  ├─ table
│  │  ├─ DataTable.tsx              # 通用表格
│  │  └─ FilterBar.tsx              # 通用筛选条
│  ├─ auth
│  │  └─ PermissionGuard.tsx
│  ├─ feedback
│  │  ├─ ErrorBoundary.tsx
│  │  └─ Loading.tsx
│  └─ common
│     ├─ Icon.tsx                   # 动态图标渲染
│     └─ EmptyState.tsx
│
├─ hooks
│  ├─ useFeatureConfig.ts           # 功能配置加载/缓存（Query）
│  ├─ useRequest.ts                 # 统一请求 Hook（基于 Query 封装）
│  ├─ usePagination.ts
│  ├─ useTableData.ts
│  └─ useTableFilter.ts
│
├─ stores
│  ├─ auth.store.ts                 # 认证/权限
│  ├─ ui.store.ts                   # UI 偏好（主题、侧边栏开合等）
│  └─ workbench.store.ts            # 工作台局部状态（本地客户端状态）
│
├─ lib
│  ├─ axios.ts                      # axios 实例 + 拦截器
│  ├─ queryClient.ts                # TanStack Query 单例
│  ├─ routes.ts                     # 路由配置与权限元信息
│  ├─ permissions.ts                # 权限计算（hasPermission）
│  ├─ validators.ts                 # 表单规则生成/跨字段校验
│  ├─ upload.ts                     # 文件上传工具（签名/直传）
│  └─ icons.ts                      # 图标注册表（字符串→组件）
│
├─ services                         # 业务 API 层（axios 调用+类型）
│  ├─ auth.api.ts
│  ├─ features.api.ts
│  ├─ forms.api.ts
│  ├─ users.api.ts
│  ├─ orders.api.ts
│  └─ tasks.api.ts
│
├─ styles
│  ├─ globals.css
│  ├─ antd-theme.ts                 # AntD 主题 Token
│  └─ tokens.ts                     # 设计系统 Token（间距/断点/阴影）
│
├─ types
│  ├─ common.ts                     # 基础类型（Result、Page、Option 等）
│  ├─ auth.ts                       # 用户/角色/权限
│  ├─ feature.ts                    # 功能定义/分类/状态/图标名
│  ├─ form.ts                       # JSON Schema（表单）
│  ├─ user.ts                       # 用户实体
│  ├─ order.ts                      # 订单实体
│  └─ task.ts                       # 任务实体
│
├─ middleware.ts                    # 全局路由守卫（基于路由元信息与 Cookie）
└─ env.d.ts                         # 环境变量类型声明
```

#### 各目录职责

* **app/**：路由与页面（App Router），布局区分公开区和受保护区；页面尽量**瘦**，容器逻辑交给 hooks + services。
* **components/**：**展示组件**（无业务）与**通用容器组件**（轻业务）分层；复用性高。
* **hooks/**：业务无关/可复用 Hook（数据加载、分页、筛选等）。
* **stores/**：Zustand 切片，**仅客户端状态**（认证、UI、临时工作台状态等）。
* **lib/**：基础设施（axios、QueryClient、权限/路由元信息、校验工具、上传工具、图标注册表）。
* **services/**：**业务 API 层**，输入输出均有类型；页面/Hook 不直接调用 axios。
* **types/**：**统一类型中心**；服务端响应类型与前端模型在此对齐。
* **styles/**：AntD 主题与自定义 Token（响应式断点/间距/色板）。

### 2) 组件分层策略

* **Layout 组件**：AppShell 等，只关心布局与导航。
* **Container 容器组件**：连接数据（useQuery/useRequest）、处理交互，**不渲染细节样式**。
* **Presentation 展示组件**：纯渲染 + 最少逻辑（props 驱动），**没有副作用**。

> 原则：页面只拼装容器与展示组件；容器只做数据与状态；展示只做UI。

### 3) 状态管理方案

* **Zustand（客户端状态）**：认证信息、主题、侧边栏开合、工作台步骤/选中项等。
* **TanStack Query（服务端状态）**：功能配置、列表数据、详情、统计等（自动缓存、重试、错误边界、并发去重）。
* **异步状态**：统一使用 **useRequest**（对 Query 的轻封装）来管理 `loading/error/data`，支持**自动重试**、**取消**。

### 4) 路由与权限管理（统一配置）

* 在 `lib/routes.ts` 定义路由元信息（需要登录、需要角色、布局槽位等）。
* `middleware.ts` 基于元信息和 Cookie（或 JWT）统一跳转，避免页面内闪烁。
* 组件级用 `<PermissionGuard>`；菜单基于元信息与 `hasPermission` 过滤。

### 5) 类型系统设计

* `types/` 下集中声明；服务 `services/*.api.ts` 的返回值使用泛型 `ApiResult<T>`。
* 若后端提供 OpenAPI/JSON Schema，建议自动生成类型（可在 CI 步骤执行）。
* 所有公共枚举（角色、状态、图标名等）使用 union literal 或 `as const` 枚举。

### 6) 样式与设计系统

* AntD 主题集中在 `styles/antd-theme.ts`，只在根布局 `app/layout.tsx` 注入一次。
* 自定义样式优先 **CSS Modules**（隔离性好），小型通用样式用全局 utility class。
* 响应式断点/间距/栅格在 `styles/tokens.ts` 统一导出。

---

### （问题1）核心代码示例

#### 示例1：根布局（主题 + Query + Zustand Provider）

```tsx
// src/app/layout.tsx
import './globals.css';
import React from 'react';
import { AntdRegistry } from '@ant-design/nextjs-registry';
import { ConfigProvider, App as AntApp, theme } from 'antd';
import { antdTheme } from '@/styles/antd-theme';
import { QueryClientProvider } from '@tanstack/react-query';
import { getQueryClient } from '@/lib/queryClient';

export const metadata = { title: 'AI 服装处理 SaaS' };

export default function RootLayout({ children }: { children: React.ReactNode }) {
  const queryClient = getQueryClient();
  return (
    <html lang="zh-CN">
      <body>
        <AntdRegistry>
          <ConfigProvider theme={{ algorithm: theme.defaultAlgorithm, token: antdTheme }}>
            <AntApp>
              <QueryClientProvider client={queryClient}>
                {children}
              </QueryClientProvider>
            </AntApp>
          </ConfigProvider>
        </AntdRegistry>
      </body>
    </html>
  );
}
```

#### 示例2：Zustand 认证切片与权限计算

```ts
// src/types/auth.ts
export type Role = 'USER' | 'AGENT' | 'ADMIN';
export type Permission =
  | 'workbench:view' | 'library:view' | 'affiliate:view' | 'admin:view' | 'admin:users:edit';

export interface User {
  id: string; email: string; roles: Role[]; permissions: Permission[];
  nickname?: string; avatarUrl?: string;
}
```

```ts
// src/stores/auth.store.ts
'use client';
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import type { User, Permission, Role } from '@/types/auth';

interface AuthState {
  user: User | null;
  token: string | null;
  setAuth: (u: User, t: string) => void;
  clear: () => void;
  hasRole: (r: Role) => boolean;
  hasPermission: (p: Permission) => boolean;
}

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      user: null,
      token: null,
      setAuth: (user, token) => set({ user, token }),
      clear: () => set({ user: null, token: null }),
      hasRole: (role) => !!get().user?.roles.includes(role),
      hasPermission: (perm) => !!get().user?.permissions.includes(perm),
    }),
    { name: 'auth' }
  )
);
```

```ts
// src/lib/permissions.ts
import type { Permission, Role } from '@/types/auth';

export const roleToPermissions: Record<Role, Permission[]> = {
  USER: ['workbench:view', 'library:view'],
  AGENT: ['workbench:view', 'library:view', 'affiliate:view'],
  ADMIN: ['workbench:view', 'library:view', 'admin:view', 'admin:users:edit'],
};

export function hasPermission(userPerms: Permission[], need: Permission) {
  return userPerms.includes(need);
}
```

#### 示例3：路由元信息与应用壳

```ts
// src/lib/routes.ts
import type { Permission, Role } from '@/types/auth';

export type RouteMeta = {
  path: string;
  title: string;
  public?: boolean;
  roles?: Role[];                 // 允许角色之一
  permissions?: Permission[];     // 需要拥有的权限之一
  layout?: 'dashboard' | 'admin' | 'public';
};

export const ROUTES: RouteMeta[] = [
  { path: '/', title: '首页', public: true, layout: 'public' },
  { path: '/login', title: '登录', public: true, layout: 'public' },
  { path: '/workbench', title: '工作台', roles: ['USER', 'AGENT', 'ADMIN'], permissions: ['workbench:view'], layout: 'dashboard' },
  { path: '/library', title: '素材库', roles: ['USER','AGENT','ADMIN'], permissions: ['library:view'], layout: 'dashboard' },
  { path: '/affiliate', title: '分销中心', roles: ['AGENT','ADMIN'], permissions: ['affiliate:view'], layout: 'dashboard' },
  { path: '/admin', title: '管理后台', roles: ['ADMIN'], permissions: ['admin:view'], layout: 'admin' },
  { path: '/admin/users', title: '用户管理', roles: ['ADMIN'], permissions: ['admin:users:edit'], layout: 'admin' },
] as const;
```

---

## 二、功能配置管理（回答问题2）

### 设计要点

* **数据驱动**：从后端读取 `feature_definitions`，使用 Query 缓存（例如 10\~30 分钟）。
* **抽象组件**：`FeatureCard` 接受通用的 `FeatureDefinition`；`FeatureGrid` 负责分组/筛选/排序。
* **图标管理**：后端返回 `icon` 字符串，前端在 `lib/icons.ts` 建立**白名单映射表**，防止 XSS/任意执行。
* **扩展性**：类别、状态、排序均通过 props/配置控制。

### 关键类型

```ts
// src/types/feature.ts
export type FeatureStatus = 'available' | 'beta' | 'disabled';
export type FeatureCategory = '基础处理' | 'AI模特' | '视频处理' | '其他';

export type IconName =
  | 'ScissorOutlined' | 'UserSwitchOutlined' | 'SkinOutlined'
  | 'VideoCameraOutlined' | 'MagicOutlined' | 'PictureOutlined';

export interface FeatureDefinition {
  feature_id: string;
  name: string;
  description?: string;
  icon: IconName;
  quota_cost: number;         // 配额成本
  status: FeatureStatus;
  category: FeatureCategory;
  gradient?: string;          // UI 扩展
  tags?: string[];
  createdAt?: string;
  updatedAt?: string;
}
```

### 图标映射（动态渲染）

```tsx
// src/lib/icons.ts
import * as Icons from '@ant-design/icons';
import type { IconName } from '@/types/feature';
import React from 'react';

const ICON_MAP: Record<IconName, React.ComponentType> = {
  ScissorOutlined: Icons.ScissorOutlined,
  UserSwitchOutlined: Icons.UserSwitchOutlined,
  SkinOutlined: Icons.SkinOutlined,
  VideoCameraOutlined: Icons.VideoCameraOutlined,
  MagicOutlined: Icons.MagicOutlined,
  PictureOutlined: Icons.PictureOutlined,
};

export function renderIcon(name: IconName, props?: Record<string, unknown>) {
  const C = ICON_MAP[name] ?? Icons.QuestionCircleOutlined;
  return <C {...props} />;
}
```

### API 加载与缓存

```ts
// src/services/features.api.ts
import { api } from '@/lib/axios';
import type { FeatureDefinition } from '@/types/feature';

export async function fetchFeatures(): Promise<FeatureDefinition[]> {
  return api.get<FeatureDefinition[]>('/features'); // GET /features 返回数组
}
```

```ts
// src/hooks/useFeatureConfig.ts
'use client';
import { useQuery } from '@tanstack/react-query';
import { fetchFeatures } from '@/services/features.api';

export function useFeatureConfig() {
  return useQuery({
    queryKey: ['features'],
    queryFn: fetchFeatures,
    staleTime: 10 * 60 * 1000,     // 10分钟
    gcTime: 60 * 60 * 1000,
  });
}
```

### FeatureCard/FeatureGrid

```tsx
// src/components/feature/FeatureCard.tsx
'use client';
import React from 'react';
import { Card, Tag, Typography } from 'antd';
import { renderIcon } from '@/lib/icons';
import type { FeatureDefinition } from '@/types/feature';
import styles from './FeatureCard.module.css';

type Props = {
  data: FeatureDefinition;
  onClick?: (f: FeatureDefinition) => void;
};

export default function FeatureCard({ data, onClick }: Props) {
  const { name, description, icon, status, gradient, tags } = data;
  return (
    <Card
      hoverable
      className={styles.card}
      style={gradient ? { background: gradient, color: '#fff' } : undefined}
      onClick={() => onClick?.(data)}
      title={<span>{renderIcon(icon, { style: { marginRight: 8 }})}{name}</span>}
      extra={status !== 'available' ? <Tag color="gold">{status.toUpperCase()}</Tag> : null}
    >
      <Typography.Paragraph ellipsis={{ rows: 2 }}>{description}</Typography.Paragraph>
      {tags?.map(t => <Tag key={t}>{t}</Tag>)}
    </Card>
  );
}
```

```tsx
// src/components/feature/FeatureGrid.tsx
'use client';
import React, { useMemo } from 'react';
import { Row, Col, Segmented, Select } from 'antd';
import type { FeatureDefinition, FeatureCategory, FeatureStatus } from '@/types/feature';
import FeatureCard from './FeatureCard';

type Props = {
  features: FeatureDefinition[];
  defaultCategory?: FeatureCategory | '全部';
  onSelect?: (f: FeatureDefinition) => void;
  orderBy?: 'hot' | 'new' | 'name';
  statusFilter?: FeatureStatus | 'all';
};

export default function FeatureGrid({
  features, defaultCategory = '全部', onSelect, orderBy = 'name', statusFilter = 'all'
}: Props) {
  const [category, setCategory] = React.useState(defaultCategory);
  const [status, setStatus] = React.useState<FeatureStatus | 'all'>(statusFilter);

  const list = useMemo(() => {
    let arr = [...features];
    if (category !== '全部') arr = arr.filter(f => f.category === category);
    if (status !== 'all') arr = arr.filter(f => f.status === status);
    if (orderBy === 'new') arr.sort((a, b) => (b.createdAt! > a.createdAt! ? 1 : -1));
    if (orderBy === 'hot') arr.sort((a, b) => (b.quota_cost - a.quota_cost)); // 这里只示例
    if (orderBy === 'name') arr.sort((a, b) => a.name.localeCompare(b.name));
    return arr;
  }, [features, category, status, orderBy]);

  return (
    <>
      <div style={{ display: 'flex', gap: 12, marginBottom: 12 }}>
        <Segmented
          options={['全部', ...new Set(features.map(f => f.category))]}
          value={category}
          onChange={(v) => setCategory(v as any)}
        />
        <Select
          style={{ width: 160 }}
          value={status}
          onChange={setStatus}
          options={[
            { label: '全部状态', value: 'all' },
            { label: '可用', value: 'available' },
            { label: '内测', value: 'beta' },
            { label: '禁用', value: 'disabled' },
          ]}
        />
      </div>

      <Row gutter={[16, 16]}>
        {list.map(f => (
          <Col key={f.feature_id} xs={24} sm={12} md={8} lg={6} xl={6}>
            <FeatureCard data={f} onClick={onSelect} />
          </Col>
        ))}
      </Row>
    </>
  );
}
```

---

## 三、动态表单系统（回答问题3）

### 架构设计

* **JSON Schema（业务裁剪版）**：后端按统一格式返回 `form_schema`。
* **字段注册表**：`type -> React 组件`，集中在 `components/forms/fields`。
* **可见性/依赖**：`visibleWhen` 支持根据其他字段值动态显示。
* **校验**：`lib/validators.ts` 将 schema 转为 AntD `rules`；支持异步与跨字段。
* **提交**：`DynamicForm` 统一 onSubmit（含文件上传/进度/错误提示）。

### 字段 Schema（扩展示例）

```ts
// src/types/form.ts
export type FieldType = 'text' | 'number' | 'enum' | 'image_upload' | 'video_upload' | 'date' | 'switch';

export type VisibleWhen =
  | { field: string; equals?: unknown; notEquals?: unknown; in?: unknown[]; notIn?: unknown[] }
  | { and: VisibleWhen[] }
  | { or: VisibleWhen[] };

export interface FieldSchemaBase {
  name: string;
  label: string;
  type: FieldType;
  required?: boolean;
  description?: string;
  visibleWhen?: VisibleWhen;
}

export interface TextSchema extends FieldSchemaBase {
  type: 'text'; maxLength?: number; placeholder?: string;
}
export interface NumberSchema extends FieldSchemaBase {
  type: 'number'; min?: number; max?: number; step?: number; default?: number;
}
export interface EnumSchema extends FieldSchemaBase {
  type: 'enum'; options: string[] | { label: string; value: string }[]; multiple?: boolean;
}
export interface ImageUploadSchema extends FieldSchemaBase {
  type: 'image_upload'; validation?: { maxSizeMB?: number; accept?: string[]; maxCount?: number };
}
export interface VideoUploadSchema extends FieldSchemaBase {
  type: 'video_upload'; validation?: { maxSizeMB?: number; accept?: string[] };
}
export interface DateSchema extends FieldSchemaBase {
  type: 'date';
}
export interface SwitchSchema extends FieldSchemaBase {
  type: 'switch'; default?: boolean;
}

export type FieldSchema =
  | TextSchema | NumberSchema | EnumSchema | ImageUploadSchema | VideoUploadSchema | DateSchema | SwitchSchema;

export interface FormSchema {
  feature_id: string;
  fields: FieldSchema[];
}
```

### 动态字段注册与渲染

```tsx
// src/components/forms/fields/TextField.tsx
'use client';
import React from 'react';
import { Input } from 'antd';
import type { TextSchema } from '@/types/form';

export default function TextField({ schema }: { schema: TextSchema }) {
  return <Input placeholder={schema.placeholder} maxLength={schema.maxLength} />;
}
```

```tsx
// src/components/forms/fields/ImageUploadField.tsx
'use client';
import React from 'react';
import { Upload } from 'antd';
import type { ImageUploadSchema } from '@/types/form';

export default function ImageUploadField({ schema }: { schema: ImageUploadSchema }) {
  const { validation } = schema;
  return (
    <Upload.Dragger
      name={schema.name}
      multiple={!!validation?.maxCount && validation.maxCount > 1}
      accept={validation?.accept?.map(x => '.' + x).join(',')}
      maxCount={validation?.maxCount ?? 1}
      beforeUpload={() => false}   // 统一在提交时处理
    />
  );
}
```

```tsx
// src/components/forms/fields/index.ts
import TextField from './TextField';
import NumberField from './NumberField';
import EnumField from './EnumField';
import ImageUploadField from './ImageUploadField';
import VideoUploadField from './VideoUploadField';
import DateField from './DateField';
import SwitchField from './SwitchField';

export const FieldRegistry = {
  text: TextField,
  number: NumberField,
  enum: EnumField,
  image_upload: ImageUploadField,
  video_upload: VideoUploadField,
  date: DateField,
  switch: SwitchField,
} as const;
```

### 校验规则生成与可见性判断

```ts
// src/lib/validators.ts
import type { FieldSchema, VisibleWhen } from '@/types/form';
import type { Rule } from 'antd/es/form';

export function toRules(field: FieldSchema): Rule[] {
  const rules: Rule[] = [];
  if (field.required) rules.push({ required: true, message: `${field.label} 为必填项` });
  if (field.type === 'number') {
    const f = field as any;
    if (typeof f.min === 'number') rules.push({ type: 'number', min: f.min, message: `最小值 ${f.min}` });
    if (typeof f.max === 'number') rules.push({ type: 'number', max: f.max, message: `最大值 ${f.max}` });
  }
  return rules;
}

export function isVisible(cond: VisibleWhen | undefined, values: Record<string, unknown>): boolean {
  if (!cond) return true;
  if ('and' in cond) return cond.and.every(c => isVisible(c, values));
  if ('or' in cond) return cond.or.some(c => isVisible(c, values));
  const v = values[cond.field];
  if ('equals' in cond && v !== cond.equals) return false;
  if ('notEquals' in cond && v === cond.notEquals) return false;
  if ('in' in cond && !cond.in!.includes(v)) return false;
  if ('notIn' in cond && cond.notIn!.includes(v)) return false;
  return true;
}
```

### DynamicForm 组件

```tsx
// src/components/forms/DynamicForm.tsx
'use client';
import React from 'react';
import { Form, Button, App } from 'antd';
import { FieldRegistry } from './fields';
import { toRules, isVisible } from '@/lib/validators';
import type { FormSchema, FieldSchema } from '@/types/form';
import { uploadFiles } from '@/lib/upload';

type Props = {
  schema: FormSchema;
  onSubmit: (values: Record<string, any>) => Promise<void>;
  initialValues?: Record<string, unknown>;
  submittingText?: string;
};

export default function DynamicForm({ schema, onSubmit, initialValues, submittingText = '提交中...' }: Props) {
  const [form] = Form.useForm();
  const { message } = App.useApp();
  const [loading, setLoading] = React.useState(false);

  const fields = schema.fields;

  async function handleFinish(values: Record<string, any>) {
    try {
      setLoading(true);
      // 统一处理文件：将 Upload 组件中的文件转为实际文件对象并上传，返回 URL
      const filesPayload = await uploadFiles(values);
      const payload = { ...values, ...filesPayload };
      await onSubmit(payload);
      message.success('提交成功');
    } catch (err: any) {
      message.error(err?.message || '提交失败');
    } finally {
      setLoading(false);
    }
  }

  const currentValues = Form.useWatch([], form) || {};

  return (
    <Form form={form} layout="vertical" onFinish={handleFinish} initialValues={initialValues}>
      {fields.map((f: FieldSchema) => {
        const Comp = FieldRegistry[f.type];
        if (!Comp) return null;
        if (!isVisible(f.visibleWhen, currentValues)) return null;
        return (
          <Form.Item key={f.name} name={f.name} label={f.label} tooltip={f.description} rules={toRules(f)}>
            {/* @ts-expect-error generic component props by schema */}
            <Comp schema={f} />
          </Form.Item>
        );
      })}
      <Button type="primary" htmlType="submit" loading={loading}>{submittingText}</Button>
    </Form>
  );
}
```

### 提交与上传工具

```ts
// src/lib/upload.ts
export async function uploadFiles(values: Record<string, any>) {
  // 将 Upload 组件返回的 FileList 统一转为后端需要的 URL/ID
  const result: Record<string, any> = {};
  await Promise.all(
    Object.entries(values).map(async ([k, v]) => {
      // 这里只示例：如果是 Upload 文件列表，组装为临时对象；实际实现可走直传/签名
      if (Array.isArray(v) && v[0]?.originFileObj) {
        result[k] = v.map((i: any) => ({ name: i.name, size: i.size })); // 替换为真实上传后的地址
      }
    })
  );
  return result;
}
```

---

## 四、通用表格页面架构（回答问题4）

### 设计要点

* 把分页、筛选、数据加载彻底抽象为 Hook；表格组件只接收 `columns`、`rowKey` 和数据。
* 基于 Query 的服务端状态管理：缓存/重试/轮询。
* 统一 FilterBar 配置生成请求参数。

### Hooks

```ts
// src/hooks/usePagination.ts
'use client';
import React from 'react';

export function usePagination(initial = { page: 1, pageSize: 20 }) {
  const [page, setPage] = React.useState(initial.page);
  const [pageSize, setPageSize] = React.useState(initial.pageSize);
  const onChange = (p: number, ps: number) => { setPage(p); setPageSize(ps); };
  return { page, pageSize, setPage, setPageSize, onChange };
}
```

```ts
// src/hooks/useTableFilter.ts
'use client';
import React from 'react';

export type FilterValue = string | number | boolean | undefined | null | (string | number)[];
export type FilterState = Record<string, FilterValue>;

export function useTableFilter(initial: FilterState = {}) {
  const [filters, setFilters] = React.useState<FilterState>(initial);
  const set = (k: string, v: FilterValue) => setFilters(f => ({ ...f, [k]: v }));
  const reset = () => setFilters(initial);
  return { filters, set, reset };
}
```

```ts
// src/hooks/useTableData.ts
'use client';
import { useQuery } from '@tanstack/react-query';

type Fetcher<T> = (params: Record<string, any>) => Promise<{ list: T[]; total: number }>;

export function useTableData<T>(
  key: string,
  fetcher: Fetcher<T>,
  params: Record<string, any>,
  options?: { refetchInterval?: number }
) {
  const query = useQuery({
    queryKey: [key, params],
    queryFn: () => fetcher(params),
    keepPreviousData: true,
    refetchInterval: options?.refetchInterval,
  });
  return query;
}
```

### 通用表格与筛选条

```tsx
// src/components/table/DataTable.tsx
'use client';
import React from 'react';
import { Table } from 'antd';

type Props<T> = {
  data: T[];
  total: number;
  loading: boolean;
  rowKey: string;
  columns: any[];
  page: number;
  pageSize: number;
  onPageChange: (p: number, ps: number) => void;
  rowSelection?: any;
};

export default function DataTable<T>({
  data, total, loading, rowKey, columns, page, pageSize, onPageChange, rowSelection
}: Props<T>) {
  return (
    <Table
      rowKey={rowKey}
      columns={columns}
      dataSource={data}
      loading={loading}
      pagination={{ current: page, pageSize, total, onChange: onPageChange, showSizeChanger: true }}
      rowSelection={rowSelection}
    />
  );
}
```

```tsx
// src/components/table/FilterBar.tsx
'use client';
import React from 'react';
import { Input, Select, DatePicker, Button, Space } from 'antd';
import type { FilterState } from '@/hooks/useTableFilter';

type FilterItem =
  | { type: 'search'; key: string; placeholder?: string }
  | { type: 'select'; key: string; options: { label: string; value: any }[]; placeholder?: string }
  | { type: 'daterange'; keyStart: string; keyEnd: string };

type Props = {
  items: FilterItem[];
  value: FilterState;
  onChange: (k: string, v: any) => void;
  onReset: () => void;
  onSearch?: () => void;
};

export default function FilterBar({ items, value, onChange, onReset, onSearch }: Props) {
  return (
    <Space style={{ marginBottom: 12 }} wrap>
      {items.map((it, idx) => {
        if (it.type === 'search') {
          return <Input key={idx} allowClear placeholder={it.placeholder} value={value[it.key] as any}
            onChange={e => onChange(it.key, e.target.value)} onPressEnter={onSearch} style={{ width: 240 }} />;
        }
        if (it.type === 'select') {
          return <Select key={idx} allowClear placeholder={it.placeholder} options={it.options}
            value={value[it.key] as any} onChange={v => onChange(it.key, v)} style={{ width: 180 }} />;
        }
        if (it.type === 'daterange') {
          return <DatePicker.RangePicker key={idx} onChange={(d) => {
            onChange(it.keyStart, d?.[0]?.toISOString());
            onChange(it.keyEnd, d?.[1]?.toISOString());
          }} />;
        }
        return null;
      })}
      <Button type="primary" onClick={onSearch}>查询</Button>
      <Button onClick={onReset}>重置</Button>
    </Space>
  );
}
```

### 用户管理页面示例（完整串联）

```tsx
// src/app/admin/users/page.tsx
'use client';
import React from 'react';
import { columns } from './users.columns';
import { usePagination } from '@/hooks/usePagination';
import { useTableFilter } from '@/hooks/useTableFilter';
import { useTableData } from '@/hooks/useTableData';
import DataTable from '@/components/table/DataTable';
import FilterBar from '@/components/table/FilterBar';
import { fetchUsers } from '@/services/users.api';

export default function UsersPage() {
  const { page, pageSize, onChange } = usePagination({ page: 1, pageSize: 20 });
  const { filters, set, reset } = useTableFilter({ q: '', role: undefined });

  const params = { page, pageSize, ...filters };
  const { data, isLoading, refetch } = useTableData('users', fetchUsers, params);

  return (
    <>
      <FilterBar
        items={[
          { type: 'search', key: 'q', placeholder: '搜索邮箱/昵称' },
          { type: 'select', key: 'role', options: [
            { label: '用户', value: 'USER' }, { label: '代理', value: 'AGENT' }, { label: '管理员', value: 'ADMIN' }
          ], placeholder: '角色' }
        ]}
        value={filters}
        onChange={set}
        onReset={() => { reset(); refetch(); }}
        onSearch={() => refetch()}
      />
      <DataTable
        data={data?.list ?? []}
        total={data?.total ?? 0}
        loading={isLoading}
        rowKey="id"
        columns={columns}
        page={page}
        pageSize={pageSize}
        onPageChange={onChange}
      />
    </>
  );
}
```

```ts
// src/app/admin/users/users.columns.ts
import type { ColumnsType } from 'antd/es/table';
import type { AdminUser } from '@/types/user';
import { Tag } from 'antd';

export const columns: ColumnsType<AdminUser> = [
  { title: 'ID', dataIndex: 'id' },
  { title: '邮箱', dataIndex: 'email' },
  { title: '昵称', dataIndex: 'nickname' },
  { title: '角色', dataIndex: 'roles', render: (roles: string[]) => roles.map(r => <Tag key={r}>{r}</Tag>) },
  { title: '创建时间', dataIndex: 'createdAt' },
];
```

---

## 五、权限管理与路由守卫（回答问题5）

### 权限数据结构（Zustand 存储）

已在上文 `types/auth.ts` 与 `stores/auth.store.ts` 给出。

### Next.js 中间件（无闪烁跳转）

```ts
// src/middleware.ts
import { NextRequest, NextResponse } from 'next/server';
import { ROUTES } from '@/lib/routes';

function findRoute(pathname: string) {
  return ROUTES.find(r => r.path === pathname);
}

export function middleware(req: NextRequest) {
  const { pathname } = req.nextUrl;
  const meta = findRoute(pathname);
  if (!meta) return NextResponse.next(); // 未配置则放行
  if (meta.public) return NextResponse.next();

  const token = req.cookies.get('access_token')?.value;
  const roles = req.cookies.get('roles')?.value?.split(',') ?? []; // 简化示例

  if (!token) {
    const url = new URL('/login', req.url);
    url.searchParams.set('redirect', pathname);
    return NextResponse.redirect(url);
  }

  if (meta.roles && !meta.roles.some(r => roles.includes(r))) {
    return NextResponse.redirect(new URL('/403', req.url));
  }

  return NextResponse.next();
}

export const config = {
  matcher: [
    '/workbench',
    '/library',
    '/affiliate',
    '/admin/:path*',
  ],
};
```

### 组件级权限守卫

```tsx
// src/components/auth/PermissionGuard.tsx
'use client';
import React from 'react';
import { Result } from 'antd';
import { useAuthStore } from '@/stores/auth.store';
import type { Permission, Role } from '@/types/auth';

type Props = {
  children: React.ReactNode;
  requireRoles?: Role[];
  requirePermissions?: Permission[];
  fallback?: React.ReactNode;
};

export default function PermissionGuard({ children, requireRoles, requirePermissions, fallback }: Props) {
  const user = useAuthStore(s => s.user);
  if (!user) return fallback ?? <Result status="403" title="未登录" />;
  if (requireRoles && !requireRoles.some(r => user.roles.includes(r))) {
    return fallback ?? <Result status="403" title="无访问权限" />;
  }
  if (requirePermissions && !requirePermissions.some(p => user.permissions.includes(p))) {
    return fallback ?? <Result status="403" title="无访问权限" />;
  }
  return <>{children}</>;
}
```

### 菜单动态生成

```ts
// src/components/layout/AppShell.tsx（片段）
import { ROUTES } from '@/lib/routes';
import { useAuthStore } from '@/stores/auth.store';

function useMenuItems() {
  const user = useAuthStore(s => s.user);
  return ROUTES
    .filter(r => !r.public)
    .filter(r => {
      if (!user) return false;
      if (r.roles && !r.roles.some(x => user.roles.includes(x))) return false;
      if (r.permissions && !r.permissions.some(x => user.permissions.includes(x))) return false;
      return ['dashboard', 'admin'].includes(r.layout ?? 'dashboard');
    })
    .map(r => ({ key: r.path, label: r.title, href: r.path }));
}
```

---

## 六、API 请求与错误处理（回答问题6）

### axios 实例与拦截器

```ts
// src/lib/axios.ts
import axios, { AxiosError, AxiosRequestConfig } from 'axios';
import { message } from 'antd';
import { v4 as uuid } from 'uuid';
import { useAuthStore } from '@/stores/auth.store';

const instance = axios.create({
  baseURL: process.env.NEXT_PUBLIC_API_BASE,
  timeout: 20000,
  withCredentials: true,
});

instance.interceptors.request.use(async (config) => {
  const token = useAuthStore.getState().token;
  config.headers = {
    ...(config.headers || {}),
    Authorization: token ? `Bearer ${token}` : undefined,
    'X-Request-Id': uuid(),
  };
  return config;
});

let refreshing = false;
let pending: Array<() => void> = [];

async function refreshToken() {
  // 简化示例：实际应调用 /auth/refresh
  const res = await axios.post(`${process.env.NEXT_PUBLIC_API_BASE}/auth/refresh`, {}, { withCredentials: true });
  const newToken = res.data?.accessToken as string;
  useAuthStore.getState().setAuth({ ...(useAuthStore.getState().user as any) }, newToken);
  return newToken;
}

instance.interceptors.response.use(
  (res) => res.data, // 统一提取 data
  async (error: AxiosError<any>) => {
    const { response, config } = error;
    if (!response) {
      message.error('网络错误，请检查网络连接');
      return Promise.reject(error);
    }
    if (response.status === 401 && !config?._retry) {
      if (!refreshing) {
        refreshing = true;
        try {
          const newToken = await refreshToken();
          pending.forEach(fn => fn());
          pending = [];
          refreshing = false;
          (config as any)._retry = true;
          (config!.headers as any).Authorization = `Bearer ${newToken}`;
          return instance(config!);
        } catch (e) {
          refreshing = false;
          useAuthStore.getState().clear();
          if (typeof window !== 'undefined') window.location.href = '/login';
          return Promise.reject(e);
        }
      }
      return new Promise((resolve) => {
        pending.push(() => resolve(instance(config!)));
      });
    }

    const msg = response.data?.message || `请求失败(${response.status})`;
    if (response.status >= 500) message.error('服务器繁忙，请稍后重试');
    else message.warning(msg);
    return Promise.reject(error);
  }
);

export const api = {
  get<T>(url: string, config?: AxiosRequestConfig) { return instance.get<any, T>(url, config); },
  post<T>(url: string, data?: any, config?: AxiosRequestConfig) { return instance.post<any, T>(url, data, config); },
  put<T>(url: string, data?: any, config?: AxiosRequestConfig) { return instance.put<any, T>(url, data, config); },
  delete<T>(url: string, config?: AxiosRequestConfig) { return instance.delete<any, T>(url, config); },
};
```

### useRequest Hook（基于 Query 的统一封装）

```ts
// src/hooks/useRequest.ts
'use client';
import { useQuery, useMutation, UseQueryOptions, UseMutationOptions } from '@tanstack/react-query';

export function useGet<T>(key: any[], fn: () => Promise<T>, options?: Omit<UseQueryOptions<T>, 'queryKey' | 'queryFn'>) {
  return useQuery<T>({ queryKey: key, queryFn: fn, ...options });
}

export function usePost<TData, TVariables>(
  key: any[], fn: (vars: TVariables) => Promise<TData>,
  options?: Omit<UseMutationOptions<TData, unknown, TVariables, unknown>, 'mutationFn'>
) {
  return useMutation<TData, unknown, TVariables>({ mutationFn: fn, ...options });
}
```

### 页面使用示例

```tsx
// src/app/(dashboard)/workbench/page.tsx
'use client';
import React from 'react';
import { Spin } from 'antd';
import { useFeatureConfig } from '@/hooks/useFeatureConfig';
import FeatureGrid from '@/components/feature/FeatureGrid';

export default function WorkbenchPage() {
  const { data, isLoading } = useFeatureConfig();
  if (isLoading) return <Spin />;

  return (
    <FeatureGrid
      features={data ?? []}
      defaultCategory="全部"
      orderBy="name"
      onSelect={(f) => { window.location.href = `/workbench/${f.feature_id}`; }}
    />
  );
}
```

---

## 七、样式与设计系统（回答问题6之样式部分 & 问题1补充）

```ts
// src/styles/antd-theme.ts
export const antdTheme = {
  colorPrimary: '#1677ff',
  borderRadius: 8,
  fontSize: 14,
  wireframe: false,
};
```

```ts
// src/styles/tokens.ts
export const tokens = {
  spacing: { xs: 4, sm: 8, md: 16, lg: 24, xl: 32 } as const,
  breakpoints: { xs: 480, sm: 576, md: 768, lg: 992, xl: 1200, xxl: 1600 } as const,
  shadow: { card: '0 6px 16px rgba(0,0,0,0.08)' } as const,
};
```

---

## 八、类型与 API 一致性（回答问题1/5结合）

* **做法**：后端返回统一包装 `{ code, message, data }` 或直接 `data`，前端 `api` 拦截器统一 `.data`。
* **建议**：契约化生成（OpenAPI → `types/`），或后端在 `form_schema`、`feature_definitions` 中提供 JSON Schema；前端用 `as const`/literal union 保证枚举一致。

```ts
// src/types/common.ts
export type PageQuery = { page: number; pageSize: number };
export type PageResult<T> = { list: T[]; total: number };
export type ApiResult<T> = T;
```

```ts
// src/services/users.api.ts
import { api } from '@/lib/axios';
import type { PageQuery, PageResult } from '@/types/common';
import type { AdminUser } from '@/types/user';

export async function fetchUsers(params: PageQuery & { q?: string; role?: string }): Promise<PageResult<AdminUser>> {
  return api.get<PageResult<AdminUser>>('/admin/users', { params });
}
```

---

## 九、最佳实践（每个问题的注意事项）

### 问题1（架构）

* **页面瘦身**：页面禁止直接写 API 调用；只组合容器与展示组件。
* **单一职责**：components 与 hooks 不要互相引用业务 API（通过 services）。
* **命名规范**：文件 `kebab-case.tsx`，类型 `PascalCase`，Zustand action 以动词开头。

### 问题2（功能配置）

* **图标白名单映射**，拒绝直接 `createElement(icons[str])` 执行任意组件名。
* **缓存时间**：功能配置变更频率不高，`staleTime` 可设 10\~30 分钟。
* **UI 扩展字段**（gradient/tags）建议保留可选，前端做默认值。

### 问题3（动态表单）

* **字段可见性**逻辑统一到 `isVisible`，避免散落在组件内。
* **文件处理**：统一在提交时转换/上传，字段组件只负责选择文件。
* **校验规则生成**放在 `lib/validators.ts`，支持跨字段（如开始时间 < 结束时间）。

### 问题4（通用表格）

* **查询防抖**：搜索框 `onChange` 只更新 state，`onSearch` 或 300ms 防抖再 `refetch`。
* **分页与筛选**：`queryKey` 包含 `params`，Query 自动缓存和并发去重。
* **批量操作**：用 `rowSelection` + 统一的 `selectedRowKeys` 管理。

### 问题5（权限）

* **中间件先行**：在服务端直接重定向，避免“先渲染再跳转”的闪烁。
* **菜单/按钮**：统一通过 `<PermissionGuard>` 包裹或对 `items` 先过滤。
* **Cookie 与 Store 对齐**：登录后将角色/权限写入 Cookie（中间件用）与 Store（客户端用）。

### 问题6（API）

* **错误提示统一**：拦截器层统一 `message.error`，页面不再重复 try-catch。
* **取消请求**：Query 内部支持取消；必要时传入 `signal`。
* **链路追踪**：`X-Request-Id` 加强排障。

---

## 十、迁移方案（分阶段，不影响线上）

**阶段0：基础设施落地（低风险，1-2天）**

1. 新增 `lib/axios.ts`、`lib/queryClient.ts`、`stores/auth.store.ts`、`styles/antd-theme.ts`。
2. 根布局接入 ConfigProvider + QueryClientProvider。
3. 建立 `types/` 与 `services/` 目录，抽取 1\~2 个 API 做示范。

**阶段1：路由与权限（1-2天）**

1. 引入 `lib/routes.ts` 路由元信息，补全关键路径。
2. 实施 `middleware.ts`，将权限判断从页面 useEffect 移除。
3. 导航菜单改为基于 `ROUTES` 生成。

**阶段2：功能配置驱动（2-3天）**

1. 替换 `page.tsx` 中的 670 行硬编码 → `useFeatureConfig + FeatureGrid`。
2. 建立 `lib/icons.ts` 白名单映射；服务端 icon 字段与前端类型对齐。
3. 工作台子页面按 feature\_id 动态渲染。

**阶段3：动态表单引擎（3-5天）**

1. 新建 `DynamicForm` 和字段注册表。
2. 选 3 个差异化功能迁移为 schema 驱动。
3. 抽象 `validators` 与 `upload`，统一提交流程。

**阶段4：通用表格与 Hook（3-5天）**

1. 落地 `usePagination/useTableFilter/useTableData` 与 `DataTable/FilterBar`。
2. 先迁移“用户管理”，再推广到订单、任务、分销。
3. 加入轮询和手动刷新规范。

**阶段5：类型与规范（并行）**

1. TypeScript 严格模式开启，修复 any。
2. 将散落类型集中至 `types/`；services 输出统一泛型。
3. 建立 ESLint/Prettier/commitlint/CI 检查（避免回归）。

**风险与缓解**

* **权限中断**：先灰度开启 `middleware`，保留页面内兜底跳转 1\~2 天。
* **表单功能差异**：先迁移简单 schema，复杂功能保留临时扩展字段或自定义渲染器。
* **缓存一致性**：重要配置（features）变更后调用 `queryClient.invalidateQueries(['features'])`。

---

## 十一、文件命名规范（选摘）

* 组件：`PascalCase.tsx`（如 `FeatureCard.tsx`）
* hooks：`useXxx.ts`（如 `useTableData.ts`）
* store：`xxx.store.ts`
* api：`xxx.api.ts`
* 类型：`snake-case.ts`（按领域 `user.ts` / `feature.ts`）

---

## 十二、数据流图（ASCII）

```
[Page(Server)] -> [Layout] -> [Container(Client)]
      |                             |
      |                         useQuery/useRequest ----> [services/*.api.ts] ---> [axios拦截器]
      |                             |                                          ↘
      |                             |                                           [缓存/重试/错误处理]
      |                             |
   [Zustand(auth/ui)] <-------- 读写权限/主题等 -------------------------------/
      |
 [middleware.ts]（基于 Cookie 进行服务端路由守卫）
```

---

## 十三、补充代码：QueryClient 单例与 Admin 布局示例

```ts
// src/lib/queryClient.ts
import { QueryClient } from '@tanstack/react-query';

let client: QueryClient | null = null;

export const getQueryClient = () => {
  if (!client) {
    client = new QueryClient({
      defaultOptions: {
        queries: {
          refetchOnWindowFocus: false,
          retry: 2,
        },
      },
    });
  }
  return client;
};
```

```tsx
// src/app/admin/layout.tsx
import React from 'react';
import PermissionGuard from '@/components/auth/PermissionGuard';
import AppShell from '@/components/layout/AppShell';

export default function AdminLayout({ children }: { children: React.ReactNode }) {
  return (
    <PermissionGuard requireRoles={['ADMIN']}>
      <AppShell menuType="admin">{children}</AppShell>
    </PermissionGuard>
  );
}
```

---

## 十四、FAQ（常见问题）

**Q1：为什么要同时使用 Zustand 和 React Query？**
A：Zustand 适合“客户端状态”（权限、UI 偏好、当前步骤），React Query 擅长“服务端状态”（列表/详情/统计，具备缓存与重试）。职责清晰，避免把异步数据塞入全局 store。

**Q2：如果后端 icon 新增了一个名字怎么办？**
A：在 `lib/icons.ts` 白名单中补充映射（或在 CI 中校验 `IconName` 是否覆盖后端实际值），避免运行时执行任意组件名。

**Q3：动态表单是否会限制个别复杂页面？**
A：支持自定义字段组件与 `visibleWhen` 组合；对极端复杂表单，可在 schema 中增加 `widget` 自定义渲染器，或局部透传 `render`。

**Q4：如何保证表格性能（1000 行 < 1s）？**
A：AntD Table 列表渲染可用 `pagination` + 服务端分页；如需一次渲染海量行，考虑 `virtual`（虚拟滚动）。同时 memo 化列定义与行 `rowKey` 稳定。

**Q5：首屏优化？**
A：公共资源（主题/字体）预加载；拆分大模块（admin 区域）为懒加载；Feature 配置延迟加载或静态预取；组件按需加载图标。

---

## ✅ 交付检查清单对照

* [x] 完整的目录结构设计（树形图）
* [x] 6个问题的详细解决方案
* [x] 每个问题至少3个可运行的代码示例

  * 问题1：根布局、auth store、路由元信息
  * 问题2：类型、图标映射、API+Hook、FeatureCard、FeatureGrid
  * 问题3：字段组件、字段注册、校验、DynamicForm、上传工具
  * 问题4：usePagination/useTableFilter/useTableData、DataTable、FilterBar、用户页
  * 问题5：middleware、PermissionGuard、菜单生成
  * 问题6：axios 拦截器、useRequest、页面示例
* [x] TypeScript 类型定义完整（types/\*、接口泛型）
* [x] 最佳实践建议（逐问题给出）
* [x] 迁移方案与步骤
* [x] 常见问题FAQ

---

如果你愿意，我可以**按你的仓库结构**把这些文件的**最小可运行骨架**拆成 commit 计划，每一步提供补丁（diff）与说明，便于团队逐步落地与 Code Review。
