下面是一份**可直接落地**的日志与链路追踪方案，覆盖技术选型对比、总体架构、字段规范、采集与存储、查询与告警，以及完整代码示例（Express.js 中间件与 SCF 处理器、OpenTelemetry 初始化、Collector 配置）。

---

## TL;DR（推荐）

* **推荐组合：B + D（腾讯云 CLS + OpenTelemetry/Jaeger）**

  * **日志**：统一落到 **腾讯云 CLS**（Cloud Log Service），原生对 **SCF** 日志“开箱即连”，支持结构化检索、索引与日志告警，并可一键归档到 **COS**（对象存储）。([Tencent Cloud][1])
  * **追踪**：全链路追踪采用 **OpenTelemetry（OTel）** SDK + **OTel Collector** 转发到 **Jaeger**。Grafana 上配置“**日志 ↔ Trace**”联动，点击日志里的 `trace_id` 直达 Trace 详情。([OpenTelemetry][2])
  * **性能**：在 **OTel Collector** 启用 `spanmetrics`，把 Trace 转换成 Prometheus 指标做 **p95/p99**、错误率与慢接口告警。([GitHub][3])

> 若更偏开源自建：**C + D（Loki + Grafana + Jaeger）** 也可，但需严格控制 Loki **label 基数**（低基数标签 + JSON 字段检索），避免成本与查询退化。([Grafana Labs][4])
> 若选择 **A（ELK）**：功能最全，但自运维成本高；可叠加 **Elastic APM** 直接做追踪（或接入 Jaeger）。([Elastic][5])

---

## 技术选型对比（A/B/C/D）

| 能力/方案  | A：ELK（+APM）              | B：腾讯云 CLS           | C：Loki + Grafana     | D：Jaeger（OTel）         |
| ------ | ------------------------ | ------------------- | -------------------- | ---------------------- |
| 日志集中   | ✅ 强                      | ✅ 托管、原生支持 SCF/TKE 等 | ✅ 强（对象存储+索引）         | ⛔（追踪而非日志）              |
| 结构化检索  | ✅（Kibana KQL）            | ✅（KV 索引、全文）         | ✅（LogQL + JSON 解析）   | ⛔                      |
| 错误聚合   | ✅（Kibana/插件）             | ✅（CLS 检索+告警规则）      | ✅（LogQL + Grafana）   | ⛔（通过 Trace tag 聚合）     |
| 链路追踪   | ✅（Elastic APM 或接 Jaeger） | ↔（与追踪系统联动，非内置）      | ↔（与 Tempo/Jaeger 联动） | ✅ 核心                   |
| SCF 集成 | ⛔ 需接入管道                  | ✅ **默认投递到 CLS**     | ⛔                    | ↔ SDK 自行上报             |
| 运维成本   | 高（集群/ILM）                | 低（托管）               | 中（容量/label 管理）       | 中（存储后端选择）              |
| 告警     | ✅（Kibana/Watcher）        | ✅（日志告警、看板）          | ✅（Grafana Alerting）  | ↔（结合 Prometheus）       |
| 费用     | 视规模偏高                    | 按量存储/检索（省运维）        | 低成本，可控               | 取决于存储（ES/Tempo/Badger） |

关键依据：

* **CLS**：原生集成 SCF、TKE、LogListener 采集；可将日志**归档到 COS** 降本；支持**KV 索引**与检索告警。([Tencent Cloud][1])
* **OTel/Jaeger**：Node/Express 自动化埋点、通过 OTel Collector 转换/导出；Jaeger v2 对 OTel 兼容更深。([OpenTelemetry][2])
* **Grafana**：支持**从日志一键跳转 Trace**；Loki 需要谨慎控制 label 基数。([Grafana Labs][6])
* **ELK**：ILM 生命周期策略管理热/温/冷/删流水线。([Elastic][5])

---

## 总体架构（建议实现）

```mermaid
flowchart LR
  subgraph Clients[Client / SDK]
    A[HTTP Request] -->|traceparent + baggage(user_id,task_id)| API
  end

  subgraph API[Express.js (多实例)]
    API -->|stdout JSON logs| Agent[LogListener/Fluent Bit]
    API -->|OTLP (HTTP/GRPC)| OTel[OTel Collector]
    API -->|HTTP/SDK| SCF[SCF 函数]
    API -->|HTTP| Provider[3rd Providers (TC/ALI)]
  end

  subgraph SCF[腾讯云 SCF]
    SCF -. console.log JSON .-> CLS
    SCF -->|OTLP| OTel
  end

  Agent --> CLS[(Tencent Cloud CLS)]
  CLS --> COS[(COS 归档)]
  OTel -->|traces| Jaeger[(Jaeger)]
  OTel -->|spanmetrics| Prom[(Prometheus)]
  Grafana[(Grafana)] -->|datasource| Jaeger
  Grafana -->|datasource| Prom
  Grafana -->|datasource| CLS
  CLS -->|告警| Notify[IM/Email/Callback]
```

* **SCF 日志默认投 CLS**，Express 输出 JSON 到本地 Agent（LogListener/TKE log agent）再送 CLS。([Tencent Cloud][1])
* OTel Collector 将 Trace 发往 Jaeger；用 **spanmetrics** 生成指标给 Prometheus，用于 **慢接口/错误率** 告警。([GitHub][3])
* Grafana 配置“**Derived Fields**/Data links”，日志中的 `trace_id` 一键跳到 Jaeger Trace。([Grafana Labs][6])

---

## 1) 日志收集方案

### Express.js（多实例）

* **应用侧**：统一使用 **JSON 结构化日志**（示例代码见下文），输出到 **stdout**。
* **节点侧 Agent**：

  * **LogListener**（官方采集器）或 **TKE log agent**（K8s）采集容器/文件日志，直传 **CLS**。([Tencent Cloud][7])
  * 也可在应用中用 **CLS Node SDK** 直接推送（适合边缘/无 Agent 环境）。([Tencent Cloud][8])

### 腾讯云 SCF（云函数）

* **SCF 执行日志**（`console.log`）**默认投递 CLS**；可在 SCF 控制台或 CLS 查询。([Tencent Cloud][1])
* 为保持结构化一致，SCF 中同样输出 **JSON**。必要时也可用 CLS SDK 主动推送业务日志。([Tencent Cloud][8])

---

## 2) 日志格式规范（JSON Schema）

> **Log schema（Draft 2020-12）**

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "AppLog",
  "type": "object",
  "required": ["ts","level","service","env","message","trace_id","span_id"],
  "properties": {
    "ts": {"type": "string", "format": "date-time"},
    "level": {"type": "string", "enum": ["debug","info","warn","error","fatal"]},
    "service": {
      "type": "object",
      "required": ["name","instance_id","version"],
      "properties": {
        "name": {"type": "string"},
        "instance_id": {"type": "string"},
        "version": {"type": "string"}
      }
    },
    "env": {"type": "string", "enum": ["dev","staging","prod"]},
    "trace_id": {"type": "string"},
    "span_id": {"type": "string"},
    "parent_span_id": {"type": "string"},
    "request": {
      "type": "object",
      "properties": {
        "route": {"type": "string"},
        "method": {"type": "string"},
        "status_code": {"type": "integer"},
        "latency_ms": {"type": "number"},
        "remote_ip": {"type": "string"},
        "user_agent": {"type": "string"}
      }
    },
    "business": {
      "type": "object",
      "properties": {
        "user_id": {"type": "string"},
        "task_id": {"type": "string"},
        "pipeline_step": {"type": "string"}
      }
    },
    "provider": {
      "type": "object",
      "properties": {
        "name": {"type": "string", "enum": ["tencent","alibaba","other"]},
        "api": {"type": "string"},
        "request_id": {"type": "string"},
        "duration_ms": {"type": "number"}
      }
    },
    "error": {
      "type": "object",
      "properties": {
        "kind": {"type": "string"},
        "message": {"type": "string"},
        "stack": {"type": "string"},
        "fingerprint": {"type": "string"}
      }
    },
    "message": {"type": "string"},
    "extra": {"type": "object", "additionalProperties": true}
  }
}
```

**字段要点**

* **必须**：`ts/level/service/env/trace_id/span_id/message`
* **可选但强烈建议**：`business.user_id/task_id`（方便按用户/任务检索）、`request.*`、`provider.*`、`error.*`
* **错误指纹**：`error.fingerprint = sha1(error.kind + top_frame + normalized_message)`，用于**错误聚合**。
* **隐私**：对手机号/邮箱/Token 等做脱敏（如末 4 位保留），大字段（栈、请求体）可截断并存 `extra`。

---

## 3) 链路追踪实现（TraceID 传递、Span 记录）

* **协议**：采用 **W3C Trace Context**（`traceparent` / `tracestate`）与 **baggage** 传递 `user_id`、`task_id` 等元数据。Express → SCF → Provider 全链路自动注入。([OpenTelemetry][2])
* **自动化**：Node 侧使用 **OTel auto-instrumentations**（含 `http`/`express`），对 **axios** 或底层 `http` 请求自动建 span 并注入 header。([OpenTelemetry][2])
* **日志-Trace 关联**：应用日志注入当前 **`trace_id`/`span_id`**；Grafana 配置 Derived Field/内部链接，从日志**跳转**到 Jaeger/Tempo 的 Trace。([Grafana Labs][6])

---

## 4) 日志存储策略（保留与归档）

* **CLS**：

  * 生产建议：**错误/审计** 90 天，**API 访问** 30 天，**DEBUG** 7 天。
  * 超期归档：启用 CLS **投递到 COS**（分桶按 `logset/topic/date=YYYY-MM-DD/`），满足合规/复盘与离线分析。([Tencent Cloud][9])
* **Trace**（Jaeger 存储）：

  * 7\~14 天即可定位问题；历史统计用 `spanmetrics` 衍生的 Prom 指标沉淀更经济。

---

## 5) 日志查询优化（索引与性能）

### 在 CLS

* 开启 **Key-Value 索引** + 全文索引；对以下字段建 **KV 索引**：
  `trace_id`, `span_id`, `service.name`, `env`, `request.route`, `request.status_code`, `business.user_id`, `business.task_id`, `error.fingerprint`。([Tencent Cloud][10])
* **查询示例**：

  * 按用户+任务：`business.user_id:"u123" AND business.task_id:"t456"`（时间范围用控制台选择）。([Tencent Cloud][10])
  * 某接口 5xx：`request.route:"/api/v1/render" AND request.status_code>=500`
  * 某 Trace 全量日志：`trace_id:"<trace id>"`

### 在 ELK（如选 A）

* 使用 **ILM**（hot/warm/cold/delete）与 **Index Template** 控制生命周期与 mapping。([Elastic][5])

### 在 Loki（如选 C）

* **严控 label**：仅将 `service`, `env`, `level`, `has_trace`（true/false）设为标签；`user_id/task_id/trace_id` 保留在 **JSON 字段**，避免**高基数标签**。([Grafana Labs][4])
* 配置 **Derived Field** 抽取 `trace_id` 超链至 Traces。([Grafana Labs][6])

---

## 6) 监控告警（错误率、慢接口）

### 从 Trace 生成指标（推荐）

* 在 **OTel Collector** 启用 `spanmetrics`，把服务端 span 按 `service.name/route/status_code` 聚合为 Prom 指标（直连 Grafana 告警）。([GitHub][3])
* **PromQL 告警示例**

  * **错误率**（5 分钟窗口 > 1%）：

    ```promql
    sum(rate(traces_spanmetrics_calls_total{span_kind="SPAN_KIND_SERVER", status_code!="STATUS_CODE_OK"}[5m]))
    /
    sum(rate(traces_spanmetrics_calls_total{span_kind="SPAN_KIND_SERVER"}[5m])) > 0.01
    ```
  * **p95 接口时延**（> 1s）：

    ```promql
    histogram_quantile(0.95,
      sum(rate(traces_spanmetrics_duration_milliseconds_bucket{service_name="api"}[5m]))
      by (le, route)
    ) > 1000
    ```
  * **SCF 慢调用**（以 `service.name="scf-pipeline"` 聚合）同理。

### 日志侧告警（CLS）

* 典型规则：**5 分钟内 error.fingerprint 计数 > 20**、**某接口 5xx 次数 > N**、**provider.name="alibaba" 错误占比 > 5%** 等。CLS 支持按检索/统计结果触发告警并回调。([main.qcloudimg.com][11])

---

## 7) 代码示例

> 下述示例均为**可直接使用的最小实现**（Node.js ≥ 18）。根据需要切换到 ESM/TS。示例中：日志使用 **pino** 输出 JSON；追踪使用 **OpenTelemetry** 并自动注入 `traceparent`；axios/HTTP 出站自动建 span；日志混入当前 `trace_id/span_id` 与业务字段。

### 7.1 OpenTelemetry 初始化（`tracing.js`）

```js
// tracing.js
'use strict';
const { NodeSDK } = require('@opentelemetry/sdk-node');
const { Resource } = require('@opentelemetry/resources');
const { SemanticResourceAttributes } = require('@opentelemetry/semantic-conventions');
const { getNodeAutoInstrumentations } = require('@opentelemetry/auto-instrumentations-node');
const { OTLPTraceExporter } = require('@opentelemetry/exporter-trace-otlp-http');
const { diag, DiagConsoleLogger, DiagLogLevel } = require('@opentelemetry/api');

diag.setLogger(new DiagConsoleLogger(), DiagLogLevel.ERROR);

const sdk = new NodeSDK({
  resource: new Resource({
    [SemanticResourceAttributes.SERVICE_NAME]: process.env.OTEL_SERVICE_NAME || 'api',
    [SemanticResourceAttributes.SERVICE_VERSION]: process.env.SERVICE_VERSION || '1.0.0',
    'deployment.environment': process.env.NODE_ENV || 'dev'
  }),
  traceExporter: new OTLPTraceExporter({
    // OTel Collector OTLP 接收器地址（HTTP）
    url: process.env.OTEL_EXPORTER_OTLP_TRACES_ENDPOINT || 'http://otel-collector:4318/v1/traces'
  }),
  instrumentations: [
    getNodeAutoInstrumentations(),
    // 如需 axios 专门增强：npm i @opentelemetry/instrumentation-axios
    // new (require('@opentelemetry/instrumentation-axios').AxiosInstrumentation)()
  ]
});

sdk.start().then(() => {
  console.log('OpenTelemetry SDK started');
}).catch((err) => {
  console.error('Error starting OpenTelemetry', err);
  process.exit(1);
});

// 在进程退出时优雅关闭
process.on('SIGTERM', async () => {
  await sdk.shutdown();
  process.exit(0);
});
```

> 依据：OTel Node + Express 自动化埋点；Collector 负责转换/导出到 Jaeger。([OpenTelemetry][2])

### 7.2 Express：日志中间件 + TraceID 注入（`app.js`）

```js
// app.js
'use strict';
require('./tracing'); // 确保最先初始化 OTel

const express = require('express');
const pino = require('pino');
const pinoHttp = require('pino-http');
const { context, trace, propagation, baggage } = require('@opentelemetry/api');
const crypto = require('crypto');

const logger = pino({
  level: process.env.LOG_LEVEL || 'info',
  // 为每条日志混入 trace/span 与基础字段
  base: {
    env: process.env.NODE_ENV || 'dev',
    service: {
      name: process.env.OTEL_SERVICE_NAME || 'api',
      instance_id: process.env.INSTANCE_ID || process.pid.toString(),
      version: process.env.SERVICE_VERSION || '1.0.0'
    }
  },
  messageKey: 'message',
  formatters: {
    level(label) {
      return { level: label };
    },
    log(object) {
      // 从 OTel 上下文获取 trace/span
      const span = trace.getSpan(context.active());
      const spanCtx = span ? span.spanContext() : undefined;
      return Object.assign(
        {
          ts: new Date().toISOString(),
          trace_id: spanCtx ? spanCtx.traceId : undefined,
          span_id: spanCtx ? spanCtx.spanId : undefined
        },
        object
      );
    }
  }
});

const app = express();
app.use(express.json());

// 将 user_id/task_id 放入 W3C baggage，贯穿后续调用（SCF/Provider）
app.use((req, res, next) => {
  const userId = req.header('x-user-id') || req.query.user_id || (req.body && req.body.user_id);
  const taskId = req.header('x-task-id') || req.query.task_id || (req.body && req.body.task_id);
  const cur = baggage.getBaggage(context.active()) || baggage.create();
  const updated = cur.setEntry('user_id', { value: String(userId || '') })
                     .setEntry('task_id', { value: String(taskId || '') });
  const ctx = propagation.setBaggage(context.active(), updated);
  return context.with(ctx, next);
});

// HTTP 访问日志（含路由耗时）
app.use(pinoHttp({
  logger,
  customLogLevel: (res, err) => err ? 'error' : (res.statusCode >= 400 ? 'warn' : 'info'),
  serializers: {
    req(req) {
      return {
        method: req.method,
        route: req.originalUrl,
        remote_ip: req.ip,
        user_agent: req.headers['user-agent']
      };
    },
    res(res) {
      return {
        status_code: res.statusCode
      };
    }
  },
  customSuccessMessage(req, res) {
    return 'http_request';
  }
}));

// 示例：调用 SCF（或内部 pipeline）/ Provider（axios 将自动注入 traceparent）
const axios = require('axios');

app.get('/api/v1/render', async (req, res, next) => {
  const start = Date.now();
  try {
    // 例：调用 SCF 网关或者内部服务
    await axios.get(process.env.PIPELINE_URL || 'http://pipeline-engine/run', { timeout: 10000 });
    // 例：调用第三方 Provider（腾讯/阿里），SDK 内部走 http 也会被 OTel 捕获
    await axios.post(process.env.PROVIDER_URL || 'http://provider/submit', { t: Date.now() }, { timeout: 10000 });

    req.log.info({
      message: 'pipeline_completed',
      business: {
        user_id: req.headers['x-user-id'] || null,
        task_id: req.headers['x-task-id'] || null,
        pipeline_step: 'render'
      },
      request: {
        route: '/api/v1/render',
        method: 'GET',
        latency_ms: Date.now() - start,
        status_code: 200
      }
    });
    res.json({ ok: true });
  } catch (e) {
    const top = (e.stack || '').split('\n')[1] || '';
    const fp = crypto.createHash('sha1')
      .update(`${e.name || 'Error'}|${top}|${String(e.message).slice(0,120)}`).digest('hex');

    req.log.error({
      message: 'pipeline_failed',
      error: { kind: e.name, message: e.message, stack: String(e.stack).slice(0, 4000), fingerprint: fp },
      business: {
        user_id: req.headers['x-user-id'] || null,
        task_id: req.headers['x-task-id'] || null,
        pipeline_step: 'render'
      },
      request: {
        route: '/api/v1/render',
        method: 'GET',
        latency_ms: Date.now() - start,
        status_code: 500
      }
    });
    next(e);
  }
});

app.listen(process.env.PORT || 3000, () => {
  logger.info({ message: 'api_started' });
});
```

### 7.3 SCF（Node.js）处理器：提取 Trace、统一 JSON 日志（`index.js`）

> **要点**：SCF 默认把 `console.log` 打到 CLS；在 **冷启动**时初始化 OTel，**每次执行**从事件或 headers 中抽取 `traceparent/baggage`，继续链路；日志结构与 API 一致。([Tencent Cloud][1])

```js
// index.js (SCF)
'use strict';
require('./tracing'); // 与 API 共用 OTel 初始化（可精简成只导出 Tracer）

const { context, propagation, trace } = require('@opentelemetry/api');
const axios = require('axios');

exports.main_handler = async (event, contextSCF) => {
  // 兼容 API 网关触发：从 event.headers 提取 trace
  const carrier = (event && event.headers) ? event.headers : {};
  const ctx = propagation.extract(context.active(), carrier);

  return await context.with(ctx, async () => {
    const start = Date.now();
    const userId = carrier['x-user-id'] || null;
    const taskId = carrier['x-task-id'] || null;

    try {
      // 示例：调用 Provider
      await axios.get(process.env.PROVIDER_URL || 'http://provider/transform', { timeout: 10000 });

      console.log(JSON.stringify({
        ts: new Date().toISOString(),
        level: 'info',
        message: 'scf_step_ok',
        service: { name: 'scf-pipeline', instance_id: contextSCF.request_id, version: process.env.SERVICE_VERSION || '1.0.0' },
        env: process.env.NODE_ENV || 'dev',
        trace_id: trace.getSpan(context.active())?.spanContext().traceId,
        span_id: trace.getSpan(context.active())?.spanContext().spanId,
        business: { user_id: userId, task_id: taskId, pipeline_step: 'scf-stage' },
        request: { route: 'SCF:handler', method: 'INVOKE', latency_ms: Date.now() - start, status_code: 200 }
      }));

      return { ok: true };
    } catch (e) {
      console.log(JSON.stringify({
        ts: new Date().toISOString(),
        level: 'error',
        message: 'scf_step_failed',
        service: { name: 'scf-pipeline', instance_id: contextSCF.request_id, version: process.env.SERVICE_VERSION || '1.0.0' },
        env: process.env.NODE_ENV || 'dev',
        trace_id: trace.getSpan(context.active())?.spanContext().traceId,
        span_id: trace.getSpan(context.active())?.spanContext().spanId,
        error: { kind: e.name, message: e.message, stack: String(e.stack).slice(0, 4000) },
        business: { user_id: userId, task_id: taskId, pipeline_step: 'scf-stage' },
        request: { route: 'SCF:handler', method: 'INVOKE', latency_ms: Date.now() - start, status_code: 500 }
      }));
      throw e;
    }
  });
};
```

### 7.4 OTel Collector（`otel-collector.yaml`）

```yaml
receivers:
  otlp:
    protocols:
      http:
      grpc:

processors:
  batch:
  # 将 trace 转成 Prom 指标
  spanmetrics:
    metrics_flush_interval: 10s
    dimensions:
      - service.name
      - http.method
      - http.route
      - http.status_code

exporters:
  jaeger:
    endpoint: jaeger:14250
    tls:
      insecure: true
  prometheus:
    endpoint: 0.0.0.0:9464

connectors:
  spanmetrics:

service:
  pipelines:
    traces:
      receivers: [otlp]
      processors: [batch]
      exporters: [jaeger, spanmetrics]
    metrics:
      receivers: [spanmetrics]
      processors: [batch]
      exporters: [prometheus]
```

> `spanmetrics` 将调用量/时延分布转成 Prom 指标供 Grafana 告警。([GitHub][3])

### 7.5（可选）直接推送日志到 CLS（无 Agent/边缘场景）

```js
// direct-cls.js
const { Producer, LogItem, Content } = require('tencentcloud-cls-sdk-js'); // npm i tencentcloud-cls-sdk-js

const client = new Producer({
  endpoint: process.env.CLS_ENDPOINT, // 如 ap-guangzhou.cls.tencentcs.com
  topic_id: process.env.CLS_TOPIC_ID,
  credential: { secretId: process.env.TENCENT_SECRET_ID, secretKey: process.env.TENCENT_SECRET_KEY },
  sendTimeout: 60
});

async function sendLog(obj) {
  const item = new LogItem();
  item.pushBack(new Content('__CONTENT__', JSON.stringify(obj)));
  item.setTime(Math.floor(Date.now() / 1000));
  await client.send(item);
}
module.exports = { sendLog };
```

> 官方 SDK 封装了 CLS 上报（压缩、重试、优雅关闭等）。注意不同地域 **endpoint**。([Tencent Cloud][8])

---

## 常用查询与联动

### CLS（Key-Value 检索）

* 指定用户 + 任务：`business.user_id:"u123" AND business.task_id:"t456"`
* 慢接口（> 2s）：`request.route:"/api/v1/render" AND request.latency_ms>2000`
* 某个 Trace：`trace_id:"<trace>"`

> 先在 Topic 上开启 **Key-Value 索引**。([Tencent Cloud][10])

### Grafana 日志 ↔ Trace

* 在 Grafana 的日志数据源（CLS/Elasticsearch/Loki）里增加 **Derived Field**：
  Name: `traceID`，Regex：`"trace_id":"([a-f0-9]+)"`，链接到 **Jaeger/Tempo** 的 Trace。([Grafana Labs][6])

### Loki（如选 C）注意

* 切勿把 `trace_id`、`user_id`、`task_id` 做成标签（**高基数**）；用 JSON 字段过滤即可。([Grafana Labs][4])

---

## 落地清单（按周）

**第 1 周**

1. 在所有服务接入 **OTel SDK** 与本文日志中间件（API、SCF）。([OpenTelemetry][2])
2. 部署 **OTel Collector + Jaeger + Prometheus/Grafana**（或使用已有 Grafana）。
3. **Express** 实例安装 **LogListener** 或 TKE **log agent**，配置采集到 **CLS**。([Tencent Cloud][7])
4. CLS 为 `trace_id/user_id/task_id/...` 开启 **KV 索引**（按上文列表）。([Tencent Cloud][10])

**第 2 周**

1. Grafana 配置 **Derived Field**（日志 → Trace）、创建 p95/错误率看板与告警。([Grafana Labs][6])
2. CLS 配置日志告警（错误指纹/5xx 次数）。([main.qcloudimg.com][11])
3. CLS 开启 **COS 归档**，设置 30/90/7 天分层保留。([Tencent Cloud][9])

---

## 为什么这套方案能解决你们的痛点？

* **日志散落** → 统一到 **CLS**（API、SCF、容器/主机），统一检索与告警；SCF 默认已接通。([Tencent Cloud][1])
* **无法追踪完整链路** → **OTel + Jaeger** 全链路 Trace；日志内含 `trace_id`，Grafana 一键联动。([jaegertracing.io][12])
* **错误难以定位** → 统一 `error.fingerprint` + CLS/Grafana 告警与聚合；Trace 标出哪个 span 出错。
* **性能瓶颈难发现** → `spanmetrics` 生成 **调用量/时延直方图**，PromQL 做 p95/p99/错误率告警。([GitHub][3])

---

### 参考与依据

* **CLS 产品与采集**：LogListener/TKE log agent、服务日志接入、SCF 默认投递 CLS、索引/告警、COS 归档。([Tencent Cloud][7])
* **OpenTelemetry/Node/Express/axios**：自动化埋点与 Collector 转换。([OpenTelemetry][2])
* **Jaeger 与 OTel**：兼容与部署要点（v2 引入 OTel 核心）。([jaegertracing.io][12])
* **Grafana 日志-Trace 联动**、**Loki 标签基数**最佳实践。([Grafana Labs][6])
* **ELK ILM 生命周期**（如选 A）。([Elastic][5])

---

如果你希望，我也可以把上述代码与 Collector 配置打包成一个 **docker-compose** 与 **Kubernetes 清单**，以及 CLS 的 **采集/索引/告警**脚本（Terraform），便于一次性启动全链路观测环境。

[1]: https://www.tencentcloud.com/document/product/583/39778?%21editLang=en&utm_source=chatgpt.com "Log Delivery Configuration - tencentcloud.com"
[2]: https://opentelemetry.io/docs/languages/js/getting-started/nodejs/?utm_source=chatgpt.com "Node.js - OpenTelemetry"
[3]: https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/connector/spanmetricsconnector/README.md?utm_source=chatgpt.com "opentelemetry-collector-contrib/connector/spanmetricsconnector/README ..."
[4]: https://grafana.com/docs/loki/latest/get-started/labels/cardinality/?utm_source=chatgpt.com "Cardinality | Grafana Loki documentation"
[5]: https://www.elastic.co/docs/manage-data/lifecycle/index-lifecycle-management?utm_source=chatgpt.com "Index lifecycle management - Elastic Docs"
[6]: https://grafana.com/docs/grafana/latest/datasources/tempo/traces-in-grafana/link-trace-id/?utm_source=chatgpt.com "Link to a trace ID | Grafana documentation"
[7]: https://www.tencentcloud.com/document/product/614/31592?%21editLang=en&utm_source=chatgpt.com "Getting Started Guide - Tencent Cloud"
[8]: https://www.tencentcloud.com/document/product/614/45006?utm_source=chatgpt.com "Uploading Log via SDK - Tencent Cloud"
[9]: https://www.tencentcloud.com/document/product/436/35266?utm_source=chatgpt.com "Using COS to Store Tencent Cloud Product Logs"
[10]: https://www.tencentcloud.com/document/product/614/50922?from_cn_redirect=1&utm_source=chatgpt.com "Configuring Indexes | Tencent Cloud"
[11]: https://main.qcloudimg.com/raw/document/intl/product/pdf/tencent-cloud_614_31591_en.pdf?utm_source=chatgpt.com "Getting Started Cloud Log Service"
[12]: https://www.jaegertracing.io/docs/1.18/deployment/opentelemetry/?utm_source=chatgpt.com "OpenTelemetry | Jaeger"
