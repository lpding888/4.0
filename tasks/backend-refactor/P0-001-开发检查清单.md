# P0-001: Saga模式配额管理 - 开发检查清单

## 📌 开始开发前（必须完成，5分钟）

### ✅ 第0步：创建Git分支（必须！）
```bash
# 从develop拉取最新代码
git checkout develop
git pull origin develop

# 创建功能分支
git checkout -b feature/P0-001-saga-quota

# 推送到远程
git push -u origin feature/P0-001-saga-quota
```

**分支名**: `feature/P0-001-saga-quota`
**为什么**: 隔离开发，避免影响develop分支，方便Code Review和回滚

---

### ✅ 第1步：阅读参考方案（建议30分钟）
**必读文件**: `docs/后端架构问题解决回答`
**重点阅读**: 第4节 - Saga模式完整实现代码

**需要理解的关键点**:
- [ ] quota_transactions表的字段设计（特别是phase和idempotent_done）
- [ ] reserve方法的forUpdate锁使用
- [ ] confirm/cancel的幂等性设计
- [ ] 如何集成到TaskService和PipelineEngine

---

### ✅ 第2步：确认环境准备就绪
**检查项**:
- [ ] 本地开发环境能正常启动（npm run dev）
- [ ] 数据库连接正常
- [ ] 能执行数据库迁移（npm run migrate:latest）
- [ ] 单元测试能正常运行（npm test）

---

## 🔨 开发过程（8个任务）

### 任务1: 创建quota_transactions表的数据库迁移文件
**文件**: `backend/src/db/migrations/20250102000001_create_quota_transactions.ts`

**完成标准**:
- [ ] 包含所有必需字段（id, task_id, user_id, amount, phase, idempotent_done）
- [ ] task_id有唯一索引
- [ ] phase使用ENUM类型（reserved/confirmed/cancelled）
- [ ] 能正确执行up()和down()

**提交代码**:
```bash
git add backend/src/db/migrations/20250102000001_create_quota_transactions.ts
git commit -m "feat(quota): 创建quota_transactions表

- 字段：id, task_id, user_id, amount, phase, idempotent_done
- 索引：task_id唯一索引
- 枚举：phase三种状态（reserved/confirmed/cancelled）

Refs: #P0-001"
git push origin feature/P0-001-saga-quota
```

---

### 任务2: 实现QuotaService的reserve方法
**文件**: `backend/src/services/quota.service.ts`

**核心逻辑**:
```typescript
async reserve(userId: string, taskId: string, amount = 1) {
  return db.transaction(async (trx) => {
    // 1. 使用forUpdate锁定用户行（防止并发超卖）
    const user = await trx('users')
      .where({ id: userId })
      .forUpdate()
      .first();

    // 2. 检查配额是否足够
    if (!user || user.quota_remaining < amount) {
      throw new AppError(ErrorCode.QUOTA_INSUFFICIENT, '配额不足,请续费', 403);
    }

    // 3. 扣减配额
    await trx('users').where({ id: userId }).update({
      quota_remaining: user.quota_remaining - amount,
    });

    // 4. 记录Reserve阶段
    await trx('quota_transactions').insert({
      id: uuid().replace(/-/g, ''),
      task_id: taskId,
      user_id: userId,
      amount,
      phase: 'reserved',
      idempotent_done: true,
    });
  });
}
```

**完成标准**:
- [ ] 使用Knex事务包裹所有操作
- [ ] 使用forUpdate()锁定用户行
- [ ] 配额不足时抛出正确的错误
- [ ] 插入quota_transactions记录（phase='reserved'）

**提交代码**:
```bash
git add backend/src/services/quota.service.ts
git commit -m "feat(quota): 实现reserve方法

- 使用forUpdate锁定用户行
- 检查配额是否足够
- 扣减配额并记录reserved状态

Refs: #P0-001"
git push origin feature/P0-001-saga-quota
```

---

### 任务3: 实现QuotaService的confirm方法
**文件**: `backend/src/services/quota.service.ts`

**核心逻辑**:
```typescript
async confirm(taskId: string) {
  const record = await db('quota_transactions')
    .where({ task_id: taskId, phase: 'reserved' })
    .first();

  // 幂等性检查：如果不是reserved状态，直接返回
  if (!record || record.idempotent_done !== true) {
    return;
  }

  await db('quota_transactions')
    .where({ task_id: taskId })
    .update({ phase: 'confirmed' });
}
```

**完成标准**:
- [ ] 幂等性检查：只更新phase='reserved'的记录
- [ ] 重复调用不会报错（直接返回）
- [ ] 更新phase='confirmed'

**提交代码**:
```bash
git add backend/src/services/quota.service.ts
git commit -m "feat(quota): 实现confirm方法

- 幂等性检查：只确认reserved状态的记录
- 更新phase为confirmed

Refs: #P0-001"
git push origin feature/P0-001-saga-quota
```

---

### 任务4: 实现QuotaService的cancel方法
**文件**: `backend/src/services/quota.service.ts`

**核心逻辑**:
```typescript
async cancel(taskId: string) {
  return db.transaction(async (trx) => {
    const record = await trx('quota_transactions')
      .where({ task_id: taskId, phase: 'reserved' })
      .first();

    // 幂等性检查
    if (!record || record.phase !== 'reserved') {
      return;
    }

    // 退还配额（使用increment原子操作）
    await trx('users')
      .where({ id: record.user_id })
      .increment('quota_remaining', record.amount);

    // 更新状态
    await trx('quota_transactions')
      .where({ task_id: taskId })
      .update({ phase: 'cancelled' });
  });
}
```

**完成标准**:
- [ ] 使用事务包裹退还配额和更新状态
- [ ] 使用increment()原子性增加配额
- [ ] 幂等性检查：只取消phase='reserved'的记录

**提交代码**:
```bash
git add backend/src/services/quota.service.ts
git commit -m "feat(quota): 实现cancel方法

- 事务中退还配额
- 使用increment原子操作
- 幂等性检查

Refs: #P0-001"
git push origin feature/P0-001-saga-quota
```

---

### 任务5: 修改TaskService集成reserve方法
**文件**: `backend/src/services/task.service.ts`

**核心逻辑**:
```typescript
async createTask(userId, featureId, inputData) {
  const taskId = uuid().replace(/-/g, '');

  // ⚠️ 关键：先预留配额，失败则不创建任务
  await quotaService.reserve(userId, taskId, 1);

  // 创建任务
  await db('tasks').insert({
    id: taskId,
    user_id: userId,
    feature_id: featureId,
    input_data: JSON.stringify(inputData),
    status: 'pending',
    created_at: db.fn.now(),
  });

  return taskId;
}
```

**完成标准**:
- [ ] 在创建任务**之前**调用reserve()
- [ ] reserve失败时不创建任务（自动抛错）
- [ ] 传递正确的taskId

**提交代码**:
```bash
git add backend/src/services/task.service.ts
git commit -m "feat(quota): TaskService集成reserve方法

- 创建任务前先预留配额
- reserve失败则不创建任务

Refs: #P0-001"
git push origin feature/P0-001-saga-quota
```

---

### 任务6: 修改PipelineEngine集成confirm/cancel方法
**文件**: `backend/src/services/pipelineEngine.service.ts`

**核心逻辑**:
```typescript
async executePipeline(taskId, featureId, inputData) {
  try {
    // 执行Pipeline逻辑
    const result = await this.executeSteps(taskId, steps, inputData);

    // ✅ 成功时确认配额扣减
    await quotaService.confirm(taskId);

    return result;
  } catch (error) {
    // ❌ 失败时取消配额扣减（退还配额）
    await quotaService.cancel(taskId);

    throw error;
  }
}
```

**完成标准**:
- [ ] 成功时调用confirm(taskId)
- [ ] 失败时调用cancel(taskId)
- [ ] 确保cancel调用在错误抛出之前

**提交代码**:
```bash
git add backend/src/services/pipelineEngine.service.ts
git commit -m "feat(quota): PipelineEngine集成confirm/cancel

- 成功时调用confirm确认扣减
- 失败时调用cancel退还配额

Refs: #P0-001"
git push origin feature/P0-001-saga-quota
```

---

### 任务7: 创建QuotaService的单元测试
**文件**: `backend/tests/services/quota.service.spec.ts`

**必须测试的场景**:
```typescript
describe('QuotaService - Saga模式', () => {
  // 测试1: reserve正常流程
  it('应该正确预留配额', async () => {
    // 配额足够时能正确扣减
  });

  // 测试2: reserve配额不足
  it('配额不足时应该抛出错误', async () => {
    // 配额不足时抛出QUOTA_INSUFFICIENT错误
  });

  // 测试3: reserve → confirm流程
  it('应该正确执行reserve → confirm流程', async () => {
    // 配额正确扣减，状态更新为confirmed
  });

  // 测试4: reserve → cancel流程
  it('应该正确执行reserve → cancel流程', async () => {
    // 配额正确退还，状态更新为cancelled
  });

  // 测试5: confirm幂等性
  it('重复confirm应该是幂等的', async () => {
    // 多次confirm不会重复操作
  });

  // 测试6: cancel幂等性
  it('重复cancel应该是幂等的', async () => {
    // 多次cancel不会重复退还配额
  });

  // 测试7: 并发reserve
  it('并发reserve应该不会超卖', async () => {
    // 使用forUpdate锁防止超卖
  });
});
```

**完成标准**:
- [ ] 至少7个测试用例
- [ ] 测试覆盖率≥85%
- [ ] 所有测试通过

**提交代码**:
```bash
git add backend/tests/services/quota.service.spec.ts
git commit -m "test(quota): 添加QuotaService单元测试

- 测试reserve/confirm/cancel正常流程
- 测试幂等性
- 测试并发场景
- 测试覆盖率：87%

Refs: #P0-001"
git push origin feature/P0-001-saga-quota
```

---

### 任务8: 创建配额Saga的集成测试
**文件**: `backend/tests/integration/quota-saga.spec.ts`

**必须测试的场景**:
```typescript
describe('配额Saga集成测试', () => {
  // 测试1: 端到端成功流程
  it('创建任务 → Pipeline成功 → 配额confirm', async () => {
    // 1. 创建任务（reserve配额）
    // 2. 执行Pipeline（成功）
    // 3. 验证配额已扣减，状态为confirmed
  });

  // 测试2: 端到端失败流程
  it('创建任务 → Pipeline失败 → 配额cancel', async () => {
    // 1. 创建任务（reserve配额）
    // 2. 执行Pipeline（失败）
    // 3. 验证配额已退还，状态为cancelled
  });
});
```

**完成标准**:
- [ ] 至少2个端到端测试
- [ ] 模拟真实的任务创建和Pipeline执行
- [ ] 所有测试通过

**提交代码**:
```bash
git add backend/tests/integration/quota-saga.spec.ts
git commit -m "test(quota): 添加配额Saga集成测试

- 测试端到端成功流程
- 测试端到端失败流程

Refs: #P0-001"
git push origin feature/P0-001-saga-quota
```

---

## 📝 开发完成后（必须完成）

### ✅ 第9步：提交Pull Request
**在GitHub/GitLab/Gitee上创建PR**

**PR标题**: `[P0-001] Saga模式配额管理`

**PR描述**（复制模板）:
```markdown
## [P0-001] Saga模式配额管理

### 任务描述
实现Saga模式配额管理，解决Pipeline执行失败时配额无法回滚的问题。

### 完成的工作
- [x] 创建`quota_transactions`表（迁移文件）
- [x] 实现`QuotaService.reserve()`方法（预留配额）
- [x] 实现`QuotaService.confirm()`方法（确认扣减）
- [x] 实现`QuotaService.cancel()`方法（退还配额）
- [x] 集成到`TaskService`（创建任务时调用reserve）
- [x] 集成到`PipelineEngine`（成功/失败调用confirm/cancel）
- [x] 单元测试（覆盖率87%）
- [x] 集成测试（端到端测试）

### 关键技术点
- 使用Knex事务确保原子性
- 使用forUpdate()行级锁防止并发超卖
- 幂等性设计：同一taskId的confirm/cancel只执行一次
- 三阶段状态管理：reserved → confirmed | cancelled

### 数据库变更
- 新增表：`quota_transactions`
- 迁移脚本：`backend/src/db/migrations/20250102000001_create_quota_transactions.ts`

### 测试结果
- 单元测试：✅ 通过（7个测试用例）
- 集成测试：✅ 通过（2个测试用例）
- 测试覆盖率：✅ 87%

### 验收标准
- [x] Pipeline执行失败时，配额能正确退还
- [x] 重复confirm/cancel不会重复操作（幂等性）
- [x] 并发场景下不会超卖配额
- [x] 单元测试覆盖率≥85%

### Reviewer检查清单
- [ ] 事务使用是否正确？
- [ ] forUpdate锁是否正确使用？
- [ ] 幂等性设计是否完善？
- [ ] 错误处理是否完善？
- [ ] 测试用例是否充分？

### 参考文档
- 任务卡：`tasks/backend-refactor/P0-001-saga-quota-management.json`
- 技术方案：`docs/后端架构问题解决回答` 第4节
```

---

### ✅ 第10步：等待Code Review并修复问题
- [ ] Reviewer提出问题后24小时内修复
- [ ] 修复后推送新commit
- [ ] 等待Reviewer再次审查

---

### ✅ 第11步：PR合并后清理分支
```bash
# 切换到develop分支
git checkout develop
git pull origin develop

# 删除本地分支
git branch -d feature/P0-001-saga-quota

# 删除远程分支（如果没有自动删除）
git push origin --delete feature/P0-001-saga-quota
```

---

## ⚠️ 注意事项

### 🚫 禁止的操作
- ❌ 绝对不允许在develop分支直接开发
- ❌ 绝对不允许跳过单元测试
- ❌ 绝对不允许Commit Message写"修改代码"、"更新"等垃圾描述
- ❌ 绝对不允许Force Push到功能分支（除非你知道自己在干什么）

### ✅ 必须遵守的规则
- ✅ 每完成一个小模块就commit一次
- ✅ Commit Message必须规范（feat/fix/test前缀）
- ✅ 所有代码通过单元测试
- ✅ 测试覆盖率≥85%
- ✅ 所有代码通过ESLint检查

---

## 📊 预估工时

| 步骤 | 预估时间 | 说明 |
|------|---------|------|
| 第0步：创建分支 | 5分钟 | 执行git命令 |
| 第1步：阅读方案 | 30分钟 | 理解技术方案 |
| 第2步：环境检查 | 10分钟 | 确认环境正常 |
| 任务1：数据库迁移 | 30分钟 | 创建表结构 |
| 任务2：reserve方法 | 1小时 | 核心逻辑 |
| 任务3：confirm方法 | 30分钟 | 幂等性检查 |
| 任务4：cancel方法 | 1小时 | 退还逻辑 |
| 任务5：TaskService集成 | 30分钟 | 调用reserve |
| 任务6：PipelineEngine集成 | 30分钟 | 调用confirm/cancel |
| 任务7：单元测试 | 2小时 | 7个测试用例 |
| 任务8：集成测试 | 1小时 | 2个端到端测试 |
| 第9步：提交PR | 30分钟 | 写PR描述 |
| 第10步：修复Review问题 | 1-2小时 | 取决于问题数量 |
| **总计** | **9-10小时** | 符合任务卡预估 |

---

**检查清单创建人**: 老王
**创建时间**: 2025-11-02
**任务卡**: P0-001-saga-quota-management.json
